<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>江欣婷&#39;s博客</title>
  
  
  <link href="https://acmicpc.top/atom.xml" rel="self"/>
  
  <link href="https://acmicpc.top/"/>
  <updated>2026-01-22T09:50:39.031Z</updated>
  <id>https://acmicpc.top/</id>
  
  <author>
    <name>江欣婷</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>从零开始编写 C 编译器 Chapter 2.1 | Front End</title>
    <link href="https://acmicpc.top/2026/01/22/write_a_c_compiler/Chapter2.1-Frontend/"/>
    <id>https://acmicpc.top/2026/01/22/write_a_c_compiler/Chapter2.1-Frontend/</id>
    <published>2026-01-22T09:07:25.000Z</published>
    <updated>2026-01-22T09:50:39.031Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Note: 所有代码、定义、术语命名都参考 Nora Sandler 的书籍 <em>Write aC Compiler</em></p></blockquote><h2 id="lexer">Lexer</h2><p>这部分没新增什么东西，只需要 <span class="math inline">\(3\)</span>个 token 类型即可。</p><table><thead><tr><th>字符序列</th><th>运算符名称</th><th>语义说明</th></tr></thead><tbody><tr><td><code>~</code></td><td>Bitwise complement</td><td>按位取反</td></tr><tr><td><code>-</code></td><td>Negation</td><td>算数负号</td></tr><tr><td><code>--</code></td><td>Decrement</td><td>自减运算符</td></tr></tbody></table><p>注意到我们新增了 <code>--</code>运算符的解析。这是因为目前编译器只支持常量，而 <code>--2</code>这样的表达式是非法的，我们应在解析阶段报错。如果我们不解析<code>--</code>，编译器会将 <code>--2</code> 识别为 <code>-(-2)</code>造成语义上的错误。所以在 Lexer 阶段我们会解析 <code>--</code>运算符，但在后续阶段，我们会忽略它。</p><p>对应的正则表达式和上一章中的标点符号 <code>;</code>, <code>(</code>一致，这里不做赘述。</p><h2 id="implementation">Implementation</h2><p><code>lib/token.ml</code>: <figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ocaml"><span class="hljs-keyword">type</span> t =<br>  <span class="hljs-comment">(* tokens with contents *)</span><br>  | <span class="hljs-type">Identifier</span> <span class="hljs-keyword">of</span> <span class="hljs-built_in">string</span><br>  | <span class="hljs-type">Constant</span> <span class="hljs-keyword">of</span> <span class="hljs-built_in">int</span><br>  <span class="hljs-comment">(* Keywords *)</span><br>  | <span class="hljs-type">KWInt</span><br>  | <span class="hljs-type">KWReturn</span><br>  | <span class="hljs-type">KWVoid</span><br>  <span class="hljs-comment">(* punctuation *)</span><br>  | <span class="hljs-type">OpenParen</span><br>  | <span class="hljs-type">CloseParen</span><br>  | <span class="hljs-type">OpenBrace</span><br>  | <span class="hljs-type">CloseBrace</span><br>  | <span class="hljs-type">Semicolon</span><br>  | <span class="hljs-type">Tilde</span><br>  | <span class="hljs-type">Hyphen</span><br>  | <span class="hljs-type">DoubleHyphen</span><br></code></pre></td></tr></table></figure></p><p><code>lib/lexer.ml</code>: <figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ocaml"><span class="hljs-keyword">let</span> match_rules =<br>  [<br>    generate_rule &#123;_|[<span class="hljs-type">A</span>-<span class="hljs-type">Za</span>-z_][<span class="hljs-type">A</span>-<span class="hljs-type">Za</span>-z0-<span class="hljs-number">9_</span>]*\b|_&#125; convert_identifier;<br>    generate_rule &#123;_|[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]+\b|_&#125; convert_constant;<br>    generate_rule &#123;_|\(|_&#125; (convert_literal <span class="hljs-type">T</span>.<span class="hljs-type">OpenParen</span>);<br>    generate_rule &#123;_|\)|_&#125; (convert_literal <span class="hljs-type">T</span>.<span class="hljs-type">CloseParen</span>);<br>    generate_rule &#123;_|\&#123;|_&#125; (convert_literal <span class="hljs-type">T</span>.<span class="hljs-type">OpenBrace</span>);<br>    generate_rule &#123;_|\&#125;|_&#125; (convert_literal <span class="hljs-type">T</span>.<span class="hljs-type">CloseBrace</span>);<br>    generate_rule <span class="hljs-string">&quot;;&quot;</span> (convert_literal <span class="hljs-type">T</span>.<span class="hljs-type">Semicolon</span>);<br>    generate_rule <span class="hljs-string">&quot;-&quot;</span> (convert_literal <span class="hljs-type">T</span>.<span class="hljs-type">Hyphen</span>);<br>    generate_rule <span class="hljs-string">&quot;--&quot;</span> (convert_literal <span class="hljs-type">T</span>.<span class="hljs-type">DoubleHyphen</span>);<br>    generate_rule <span class="hljs-string">&quot;~&quot;</span> (convert_literal <span class="hljs-type">T</span>.<span class="hljs-type">Tilde</span>);<br>  ]<br></code></pre></td></tr></table></figure></p><h2 id="parser">Parser</h2><p>更新新的 AST 定义： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ASDL">program = Program(function_definition)<br>function_definition = Function(identifier name, statement body)<br>statement = Return(exp)<br>exp = Constant(int) | Unary(unary_operator, exp)<br>unary_operator = Complement | Negate<br></code></pre></td></tr></table></figure></p><p>为 <code>exp</code> 新增了 <code>Unary</code>的定义，表示一元操作表达式，由一个 <code>unary-operator</code> 和<code>exp</code> 组成。 注意现在 <code>exp</code> 的定义是递归的：一个<code>Unary</code> 内部可能包含另一个 <code>exp</code>。</p><p>新定义了 <code>unary_operator</code> 结点，值 <code>Complement</code>对应 <code>~</code> 运算符，值 <code>Negate</code> 对应 <code>-</code>运算符。</p><p>更新后的形式文法： <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs EBNF">&lt;program&gt; ::= &lt;function&gt;<br>&lt;function&gt; ::= <span class="hljs-string">&quot;int&quot;</span> &lt;identifier&gt; <span class="hljs-string">&quot;(&quot;</span> <span class="hljs-string">&quot;void&quot;</span> <span class="hljs-string">&quot;)&quot;</span> <span class="hljs-string">&quot;&#123;&quot;</span> &lt;statement&gt; <span class="hljs-string">&quot;&#125;&quot;</span><br>&lt;statement&gt; ::= <span class="hljs-string">&quot;return&quot;</span> &lt;exp&gt; <span class="hljs-string">&quot;;&quot;</span><br>&lt;exp&gt; ::= &lt;int&gt; | &lt;unop&gt; &lt;exp&gt; | <span class="hljs-string">&quot;(&quot;</span> &lt;exp&gt; <span class="hljs-string">&quot;)&quot;</span><br>&lt;unop&gt; ::= <span class="hljs-string">&quot;-&quot;</span> | <span class="hljs-string">&quot;~&quot;</span><br>&lt;identifier&gt; ::= <span class="hljs-meta">? An identifier token ?</span><br>&lt;int&gt; ::= <span class="hljs-meta">? A constant token ?</span><br></code></pre></td></tr></table></figure></p><p>新增 <code>exp</code> 的产生式规则<code>&lt;unop&gt; &lt;exp&gt;</code> 和<code>"(" &lt;exp&gt; ")"</code>。 AST中不保留括号信息，<code>1</code>、<code>（1)</code> 和<code>((((((((1)))))))</code> 在 AST 中均表示为<code>Constant(1)</code>。注意并没有给出 递减操作符号 <code>--</code>的产生式规则，如果遇到 <code>Token.DoubleHyphen</code> 应报错。</p><p><code>&lt;unop&gt;</code> 对应 AST 中的 <code>unary_operator</code>类型。</p><p>对应 <code>parser_exp</code> 的伪代码如下： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs pseudocode">parse_exp(tokens):<br>    next_token = peek(tokens)<br>    if next_token is an int:<br>        --snip--<br>    else if next_token is &quot;~&quot; or &quot;-&quot;:<br>        operator = parse_unop(tokens)<br>        inner_exp = parse_exp(tokens)<br>        return Unary(operator, inner_exp)<br>    else if next_token == &quot;(&quot;:<br>        take_token(tokens)<br>        inner_exp = parse_exp(tokens)<br>        expect(&quot;)&quot;, tokens)<br>        return inner_exp<br>    else:<br>        fail(&quot;Malformed expression&quot;)<br></code></pre></td></tr></table></figure></p><p>其中的 <code>peek</code> 函数作用为：查看下一个 token但不消耗它。用以决定应用哪条产生式规则。如果为<strong>一元操作符</strong>，首先解析操作符类型，并递归调用<code>parse_exp</code> 解析操作数，最后构造 <code>Unary</code>结点。</p><p>如果为括号表达式，则首先消耗左括号，递归解析内部表达值，并验证右括号存在。不创建新结点，直接返回内部表达式。</p><h2 id="implementation-1">Implementation</h2><p><code>lib/Tok_stream.ml</code> <figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs coq"><span class="hljs-keyword">let</span> peek tokens =<br>  <span class="hljs-keyword">match</span> Stream.peek tokens <span class="hljs-built_in">with</span><br>  | <span class="hljs-type">Some</span> token -&gt; token<br>  | <span class="hljs-type">None</span> -&gt; raise End_of_stream<br></code></pre></td></tr></table></figure></p><p><code>lib/parser.ml</code> <figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs ocaml"><span class="hljs-comment">(* &lt;unop&gt; ::= &quot;-&quot; | &quot;~&quot; *)</span><br><span class="hljs-keyword">let</span> parse_unop tokens =<br>  <span class="hljs-keyword">match</span> <span class="hljs-type">Tok_stream</span>.take_token tokens <span class="hljs-keyword">with</span><br>  | <span class="hljs-type">T</span>.<span class="hljs-type">Tilde</span> -&gt; <span class="hljs-type">Ast</span>.<span class="hljs-type">Complement</span><br>  | <span class="hljs-type">T</span>.<span class="hljs-type">Hyphen</span> -&gt; <span class="hljs-type">Ast</span>.<span class="hljs-type">Negate</span><br>  | other -&gt; raise_error ~expected:(<span class="hljs-type">Name</span> <span class="hljs-string">&quot;a unary operator&quot;</span>) ~actual:other<br><br><span class="hljs-comment">(* &lt;exp&gt; ::= &lt;int&gt; | &lt;unop&gt; &lt;exp&gt; | &quot;(&quot; &lt;exp&gt; &quot;)&quot; *)</span><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">rec</span> parse_exp tokens =<br>  <span class="hljs-keyword">match</span> <span class="hljs-type">Tok_stream</span>.peek tokens <span class="hljs-keyword">with</span><br>  | <span class="hljs-type">T</span>.<span class="hljs-type">Constant</span> _ -&gt; parse_int tokens<br>  | <span class="hljs-type">T</span>.<span class="hljs-type">Tilde</span> | <span class="hljs-type">T</span>.<span class="hljs-type">Hyphen</span> -&gt;<br>      <span class="hljs-keyword">let</span> opera = parse_unop tokens <span class="hljs-keyword">in</span><br>      <span class="hljs-keyword">let</span> inner_exp = parse_exp tokens <span class="hljs-keyword">in</span><br>      <span class="hljs-type">Unary</span> (opera, inner_exp)<br>  | <span class="hljs-type">T</span>.<span class="hljs-type">OpenParen</span> -&gt;<br>      <span class="hljs-keyword">let</span> _ = <span class="hljs-type">Tok_stream</span>.take_token tokens <span class="hljs-keyword">in</span><br>      <span class="hljs-keyword">let</span> expr = parse_exp tokens <span class="hljs-keyword">in</span><br>      expect <span class="hljs-type">T</span>.<span class="hljs-type">CloseParen</span> tokens;<br>      expr<br>  | other -&gt; raise_error ~expected:(<span class="hljs-type">Name</span> <span class="hljs-string">&quot;an expression&quot;</span>) ~actual:other<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Note: 所有代码、定义、术语命名都参考 Nora Sandler 的书籍 &lt;em&gt;Write a
C Compiler&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;lexer&quot;&gt;Lexer&lt;/h2&gt;
&lt;p&gt;这部分没新增什么东西</summary>
      
    
    
    
    <category term="compiler" scheme="https://acmicpc.top/categories/compiler/"/>
    
    
    <category term="compiler" scheme="https://acmicpc.top/tags/compiler/"/>
    
  </entry>
  
  <entry>
    <title>从零开始编写 C 编译器 Chapter 2.0 | Runtime Stack</title>
    <link href="https://acmicpc.top/2026/01/22/write_a_c_compiler/Chapter2.0-Stack/"/>
    <id>https://acmicpc.top/2026/01/22/write_a_c_compiler/Chapter2.0-Stack/</id>
    <published>2026-01-22T07:07:25.000Z</published>
    <updated>2026-01-22T09:14:06.831Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Note: 所有代码、定义、术语命名都参考 Nora Sandler 的书籍 <em>Write aC Compiler</em></p></blockquote><p>在 Chapter 1 中我们实现了对 <code>return</code> 语句和<code>constant</code> 的支持。这章将会实现对一元运算符(unaryoperator)的支持。具体的说，是 算数负号运算符 <code>-</code> 和按位取反运算符 <code>~</code> 的支持。同时还引入 IR来化简生成汇编的难度。</p><h2 id="introduce">Introduce</h2><p>考虑下列的 C 程序： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> ~(<span class="hljs-number">-2</span>);<br>&#125;<br></code></pre></td></tr></table></figure></p><p>这份代码包含嵌套的表达式<code>~(-2)</code>，每个表达式都包含一个一元运算符：Negation(<code>-</code>) 或 Complement(<code>~</code>)。下表列出了这俩运算符的语义。</p><table><thead><tr><th>运算符</th><th>含义</th><th>示例</th><th>说明</th></tr></thead><tbody><tr><td><code>-</code></td><td>算数取负</td><td>-2 -&gt; 2</td><td>整数取负</td></tr><tr><td><code>~</code></td><td>按位取反</td><td>~(-2) -&gt; 1</td><td>在补码系统中，~x = -x = 1</td></tr></tbody></table><p>在本章结束后，我们的编译器应该生成如下汇编代码： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs asm">    .globl main<br>main:<br>    pushq    %rbp<br>    movq     %rsp, %rbp<br>    subq     $8, %rsp<br><br>    movl     $2, -4(%rbp)<br>    negl     -4(%rbp)<br><br>    movl     -4(%rbp), %r10d<br>    movl     %r10d, -8(%rbp)<br>    notl     -8(%rbp)<br><br>    movl     -8(%rbp), %eax<br>    movq     %rbp, %rsp<br>    popq     %rbp<br><br>    ret<br></code></pre></td></tr></table></figure></p><p>现代编译器会进行一系列的优化，可能会直接在编译的时候计算出最终结果，所以汇编指令只有一条指令：<code>$movl $1, %rax</code>。目前我们不考虑优化。</p><p>我们目前没有编写寄存器分配，所以临时变量都暂时存放在栈上。开始的 3条指令被称为 <strong>函数序言(functionprologue)</strong>，是值在调用开始和结束时，由编译器自动生成的一段机器代码，用于建立和保存调用上下文，为局部变量分配空间，确保函数能正确执行并安全返回。目前，它的作用为将<code>%rbp</code> 的值压入栈中，并将栈顶的值 <code>%rsp</code> 复制给<code>%rbp</code>，并分配 <span class="math inline">\(8\)</span>字节的空间给新栈，用于存储局部变量。后续会有更详细的关于运行时栈的解释。<code>%rsp</code>为 Stack Pointer Register，用于存储当前函数栈帧的栈顶元素地址。</p><p>第一条 <code>movl</code> 语句将 立即数 <spanclass="math inline">\(2\)</span> 到一个内存地址中。<code>-4(%rbp)</code>为寄存器寻址，表示地址为 <span class="math inline">\([rbp] - 4\)</span>的内存空间。<code>%rbp</code> 为 Base PointerRegister，一般用于保存当前函数栈帧的栈地地址，所以 <code>-4(%rbp)</code>表示比 <code>%rbp</code> 小 4 的地址。之后 <code>negl</code>指令将该地址中的值取负。</p><p><code>mov</code> 指令的 源地址 <code>src</code> 和目的地址<code>dst</code> 不能同时为内存，所以用 <code>%r10d</code>来作为中转，通过两条 <code>mov</code> 指令将 <code>-4(%rbp)</code>中的值转移到 <code>-8(%rbp)</code> 中。之后使用 <code>notl</code>指令进行取反。</p><p>末尾的 3 条指令被称为 <strong>函数尾声(functionepilogue)</strong>，与函数序言对应，用于传递返回值，恢复现场，释放全局变量。</p><p>在 System V ABI 中，函数栈帧的栈底指针为 <code>%rbp</code>寄存器，函数栈帧的栈顶指针为 <code>%rsp</code>，函数的返回值通过<code>%rax</code> 寄存器传递。</p><h2 id="runtime-stack">Runtime Stack</h2><p>每个函数调用之后，编译器都会在内存中分配一块连续的地址空间，用于存储当前函数内的局部变量，临时计算结果等，这块空间被称为函数栈帧。所有函数调用的函数栈帧合起来被称为运行时栈 (Runtime Stack)，也就是常说的栈区。</p><p>函数栈帧方向向低地址增长：栈顶实际上是栈中最低的内存地址。所以我们才会使用<code>%subq $8 %rsp</code> 来为栈分配 <spanclass="math inline">\(8\)</span> 字节的空间。同样，当我们向栈内 push一个值的时候，<code>%rsp</code> 自动执行减操作。当执行<code>pushq $3</code> 这样的指令的时候，实际执行了下面的操作：</p><ul><li>将 <span class="math inline">\(3\)</span>放入栈顶的下一个空间。<code>q</code> 后缀表明 <spanclass="math inline">\(3\)</span> 的类型为 long long，占用 <spanclass="math inline">\(8\)</span> 字节的空间。</li><li>将 <code>%rsp</code> 的值减 <spanclass="math inline">\(8\)</span>。<code>%rsp</code>值向的是栈顶元素的最低地址，即 <span class="math inline">\(3\)</span>所占第一个字节。</li></ul><p><imgsrc="/img/write_a_c_compiler/Chapter_2/2026-01-22_16_50_36.png" /></p><p><code>popq src</code> 指令执行相反的操作：将 <code>%rsp</code>所指的元素复制到 <code>src</code> 中，然后将 <code>rsp</code> 加 <spanclass="math inline">\(8\)</span>。</p><p>每当调用一个函数的时候，我们会通过 <code>pushq %rbp</code>将上一个函数的栈底地址存入栈中。之后将栈顶地址 <code>%rsp</code> 复制给<code>%rbp</code>，将当前栈顶设为新栈帧的基地址。此时，栈顶和栈底都是同一个位置，表明当前栈帧为空。之后通过<code>subq</code> 指令将 <code>%rsp</code> 往下移动 <spanclass="math inline">\(n\)</span> 个字节。这样当前栈帧就有了 <spanclass="math inline">\(n\)</span>个字节的可用空间，用于存储临时变量。这就是 function prologue的实现原理。</p><p><imgsrc="/img/write_a_c_compiler/Chapter_2/2026-01-22_17_02_04.png" /></p><p>function epilogue 也是同理，只不过执行相反的操作。</p><ul><li><code>movq %rbp, %rsp</code> 将 <code>%rsp</code> 重置为<code>%rbp</code>, 恢复栈为空的状态。也可以使用<code>addq $8, %rsp</code>来实现同样的操作，但是加法运算慢于寄存器赋值运算。</li><li><code>popq %rbp</code> 将刚开始压入栈顶的老 <code>%rbp</code>值恢复，<code>%rsp</code> 自动加 <spanclass="math inline">\(8\)</span>，这样就恢复到了调用前的状态。</li></ul><p><imgsrc="/img/write_a_c_compiler/Chapter_2/2026-01-22_17_08_37.png" /></p><p>C语言中支持嵌套的表达式，但汇编语言中不支持。我们需要一系列的临时变量来存储这些中间值。正常来说，编译器会实现一套<strong>寄存器分配算法</strong>来管理和分配寄存器，但这部分过于复杂，目前所有运算都将在栈上运行。</p><p>在解析 function_definition的时候，我们需要顺带解析出需要多少局部变量，并自动生成 function prologue和 funciton epilogue 为栈上分配空间。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Note: 所有代码、定义、术语命名都参考 Nora Sandler 的书籍 &lt;em&gt;Write a
C Compiler&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在 Chapter 1 中我们实现了对 &lt;code&gt;return&lt;/co</summary>
      
    
    
    
    <category term="compiler" scheme="https://acmicpc.top/categories/compiler/"/>
    
    
    <category term="compiler" scheme="https://acmicpc.top/tags/compiler/"/>
    
  </entry>
  
  <entry>
    <title>从零开始编写 C 编译器 Chapter 1.3 | Codegen</title>
    <link href="https://acmicpc.top/2026/01/17/write_a_c_compiler/Chapter1.3-Codegen/"/>
    <id>https://acmicpc.top/2026/01/17/write_a_c_compiler/Chapter1.3-Codegen/</id>
    <published>2026-01-17T13:07:25.000Z</published>
    <updated>2026-01-18T16:01:16.438Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Note: 所有代码、定义、术语命名都参考 Nora Sandler 的书籍 <em>Write aC Compiler</em></p></blockquote><h2 id="assembly-generation">Assembly Generation</h2><p>Assembly Generate 阶段需要将 AST 转换为 <code>x64</code>汇编代码。转换过程会按照程序执行顺序遍历AST，并为每个结点生成对应的汇编指令。由于为了兼容后续生成IR，我们不会直接将汇编指令输出到文件，而是先构建一个中间数据结构 —— 汇编AST。</p><p>对于汇编 AST，我们采用和 AST 相同的 ASDL 语言来进行定义。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ASDL">program = Program(function_definition)<br>function_definition = Function(identifier name, instruction* instructions)<br>instruction = Mov(operand src, operand dst) | Ret<br>operand = Imm(int) | Register<br></code></pre></td></tr></table></figure></p><p>每一行都定义了一个结点，表示一个特定的汇编结构。<code>program</code>表示了整个汇编程序，包含一个函数定义。<code>function_definition</code>包括两个部分：一个函数名和一个指令列表。<code>instruction*</code> 中的<code>*</code> 表明该项可能包含多条<code>instruction</code>。<code>instruction</code>目前只支持两种指令：<code>Mov(src, dst)</code> 和<code>Ret</code>。<code>Mov</code> 指令用于将源操作数 <code>src</code>复制到目标操作数 <code>dst</code>。<code>Ret</code>无操作数，表示函数返回。<code>Operand</code>目前只支持两种操作：<code>Imm(int)</code> 整型常量和<code>Register</code> 寄存器(当然，目前只支持 <code>%rax</code>寄存器)。</p><p>目前的汇编 AST 和 AST 十分相似，我们通过一张表来表明他们的区别：</p><table><thead><tr><th>AST</th><th>Assembly AST</th></tr></thead><tbody><tr><td><code>Program(func_def)</code></td><td><code>Program(func_def)</code></td></tr><tr><td><code>Function(name, body)</code></td><td><code>Function(name, instructions)</code></td></tr><tr><td><code>Return(exp)</code></td><td>1. <code>Mov(src, dst)</code> 2. <code>Ret</code></td></tr><tr><td><code>Constant(n)</code></td><td><code>Imm(n)</code></td></tr></tbody></table><p>可以看到，AST 中的一个结点可能会生成 <strong>多个</strong> 汇编 AST结点(<code>Return(exp)</code> 生成两个 <code>instruction</code>结点)，且汇编 AST 没有表达式，操作数只能为 <strong>寄存器</strong> 或<strong>表达式经过计算后的最终值</strong>。</p><h2 id="implementation">Implementation</h2><p>对于 Assembly AST 的定义，和 AST 十分相似，只需要注意<code>instruction</code> 即可。 <figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ocaml"><span class="hljs-keyword">type</span> operand = <br>  | <span class="hljs-type">Imm</span> <span class="hljs-keyword">of</span> <span class="hljs-built_in">int</span><br>  | <span class="hljs-type">Register</span><br><br><span class="hljs-keyword">type</span> instruction = <br>  | <span class="hljs-type">Mov</span> <span class="hljs-keyword">of</span> operand * operand<br>  | <span class="hljs-type">Ret</span><br><br><span class="hljs-keyword">type</span> function_definition = <br>  | <span class="hljs-type">Function</span> <span class="hljs-keyword">of</span> &#123;name : <span class="hljs-built_in">string</span>; instructions : instruction <span class="hljs-built_in">list</span>&#125;<br><br><span class="hljs-keyword">type</span> t = <br>  | <span class="hljs-type">Program</span> <span class="hljs-keyword">of</span> function_definition<br></code></pre></td></tr></table></figure></p><p>同样采用 <strong>递归下降式解析</strong>，为每一个类型编写一个<code>convert</code> 函数。 <figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs coq"><span class="hljs-keyword">let</span> convert_exp (Ast.<span class="hljs-keyword">Constant</span> i) = Assembly.Imm i<br><br><span class="hljs-keyword">let</span> convert_statement (Ast.Return e) = <br>  <span class="hljs-keyword">let</span> value = convert_exp e <span class="hljs-built_in">in</span><br>  Assembly.[Mov (value, Register);  Ret]<br><br><span class="hljs-keyword">let</span> convert_function (Ast.<span class="hljs-keyword">Function</span> &#123;name; body&#125;) = <br>  <span class="hljs-keyword">let</span> inst_list = convert_statement body <span class="hljs-built_in">in</span><br>  Assembly.<span class="hljs-keyword">Function</span>&#123;name; instructions=inst_list&#125;<br><br><span class="hljs-keyword">let</span> codegen (Ast.<span class="hljs-keyword">Program</span> func_def) = <br>  Assembly.<span class="hljs-keyword">Program</span> (convert_function func_def)<br></code></pre></td></tr></table></figure></p><p>将 AST 转换为汇编 AST ，目前来看纯是在<sub>脱裤子放屁</sub>。但在后续引入更复杂的语义结构时，这种结构能很容易的生成IR，方便进行 <strong>编译器优化</strong> 和<strong>代码生成</strong>。</p><h2 id="code-emission">Code Emission</h2><p>汇编 AST 与最终的汇编代码高度对应，因此 Code Emission实现特别简单。只需要按照汇编 AST的结点逐一翻译即可。唯一需要注意的是需要处理平台相关的差异。这里仅考虑<code>Unix like</code> 的操作系统。</p><p>目前遇到的平台差异只有两条：</p><ul><li>在 <code>Mac OS</code>中，所有的全局符号前需要加下划线<code>_</code>，例如 <code>main</code>应该为 <code>_main</code>。</li><li>在 <code>Linux</code> 中可以在汇编文件末尾添加指令<code>.section .note.GNU-stack,"",@progbits</code>。</li></ul><p><code>.section .note.GNU-stack</code>告知链接器此程序不需要可执行栈(non-executablestack)，是一项基本的防御措施。</p><p>接下来通过几张表即可表示从汇编 AST 到 Assembly Code 的对应关系。</p><table><thead><tr><th>Assembly top-level construct</th><th>Output</th></tr></thead><tbody><tr><td><code>Program(func_def)</code></td><td>当为 Linux 平台时，在末尾添加 <code>non-exectuable stack</code>声明</td></tr><tr><td><code>Function(name, instructions)</code></td><td><code>.globl &lt;name&gt;</code> <br> <code>&lt;name&gt;:</code><br> <code>&lt;instructions&gt;</code></td></tr></tbody></table><table><thead><tr><th>Assembly instruction</th><th>Output</th></tr></thead><tbody><tr><td><code>Mov(src, dst)</code></td><td><code>movl &lt;src&gt;, &lt;dst&gt;</code></td></tr><tr><td><code>Ret</code></td><td><code>ret</code></td></tr></tbody></table><table><thead><tr><th>Assembly operand</th><th>Output</th></tr></thead><tbody><tr><td><code>Register</code></td><td><code>%eax</code></td></tr><tr><td><code>Imm(int)</code></td><td><code>$&lt;int&gt;</code></td></tr></tbody></table><h2 id="implementation-1">Implementation</h2><p>这部分没啥好说的，遍历一个 ASTNODE，将其转换为对应字符串输入文件即可。注意汇编语言的格式，在合适的地方添加制表符<code>\t</code>。</p><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs ocaml"><span class="hljs-keyword">open</span> <span class="hljs-type">Assembly</span><br><br><span class="hljs-keyword">let</span> show_operand = <span class="hljs-keyword">function</span><br>  | <span class="hljs-type">Register</span> -&gt; <span class="hljs-string">&quot;%eax&quot;</span><br>  | <span class="hljs-type">Imm</span> i -&gt; <span class="hljs-type">Printf</span>.sprintf <span class="hljs-string">&quot;$%d&quot;</span> i<br><br><span class="hljs-keyword">let</span> show_label name = <br>  <span class="hljs-keyword">match</span> !<span class="hljs-type">Settings</span>.platform <span class="hljs-keyword">with</span><br>  | <span class="hljs-type">OS_X</span> -&gt; <span class="hljs-string">&quot;_&quot;</span> ^ name<br>  | <span class="hljs-type">Linux</span> -&gt; name<br><br><span class="hljs-keyword">let</span> emit_instruction chan = <span class="hljs-keyword">function</span><br>  | <span class="hljs-type">Mov</span> (src, dst) -&gt;<br>      <span class="hljs-type">Printf</span>.fprintf chan <span class="hljs-string">&quot;\tmovl %s, %s\n&quot;</span> <br>      (show_operand src)<br>      (show_operand dst)<br>  | <span class="hljs-type">Ret</span> -&gt; <span class="hljs-type">Printf</span>.fprintf chan <span class="hljs-string">&quot;\tret\n&quot;</span><br><br><span class="hljs-keyword">let</span> emit_function chan (<span class="hljs-type">Function</span> &#123;name; instructions&#125;) = <br>  <span class="hljs-keyword">let</span> label = show_label name <span class="hljs-keyword">in</span><br>  <span class="hljs-type">Printf</span>.fprintf chan &#123;|<br>  .globl %s<br>%s:<br>  |&#125; label label;<br>  <span class="hljs-type">List</span>.iter (emit_instruction chan) instructions<br><br><span class="hljs-keyword">let</span> emit_stack_note chan = <br>  <span class="hljs-keyword">match</span> !<span class="hljs-type">Settings</span>.platform <span class="hljs-keyword">with</span><br>  | <span class="hljs-type">OS_X</span> -&gt; <span class="hljs-literal">()</span><br>  | <span class="hljs-type">Linux</span> -&gt; <span class="hljs-type">Printf</span>.fprintf chan <span class="hljs-string">&quot;\t.section .note.GNU-stack,\&quot;\&quot;,@progbits\n&quot;</span><br><br><span class="hljs-keyword">let</span> emit assembly_file (<span class="hljs-type">Program</span> function_def) = <br>  <span class="hljs-keyword">let</span> output_channel = open_out assembly_file <span class="hljs-keyword">in</span><br>  emit_function output_channel function_def;<br>  emit_stack_note output_channel;<br>  close_out output_channel<br></code></pre></td></tr></table></figure><p>至此，我们的编译器能编译一个 <em>最简 C 程序了</em>，尽管它比 "HelloWorld" 还简单，但是这是从 <span class="math inline">\(0\)</span> 到<span class="math inline">\(1\)</span> 的第一步。</p><p>结合 Compiler Driver 得到最终可执行文件，看看是否正确<code>return</code> 了 <span class="math inline">\(2\)</span>。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">./main.exe return_2.c <br>./return_2<br><span class="hljs-built_in">echo</span> $?<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Note: 所有代码、定义、术语命名都参考 Nora Sandler 的书籍 &lt;em&gt;Write a
C Compiler&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;assembly-generation&quot;&gt;Assembly G</summary>
      
    
    
    
    <category term="compiler" scheme="https://acmicpc.top/categories/compiler/"/>
    
    
    <category term="compiler" scheme="https://acmicpc.top/tags/compiler/"/>
    
  </entry>
  
  <entry>
    <title>从零开始编写 C 编译器 Chapter 1.2 | Parser</title>
    <link href="https://acmicpc.top/2026/01/16/write_a_c_compiler/Chapter1.2-Parser/"/>
    <id>https://acmicpc.top/2026/01/16/write_a_c_compiler/Chapter1.2-Parser/</id>
    <published>2026-01-16T15:07:25.000Z</published>
    <updated>2026-01-19T04:17:55.577Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Note: 所有代码、定义、术语命名都参考 Nora Sandler 的书籍 <em>Write aC Compiler</em></p></blockquote><h2 id="parser">Parser</h2><p>源代码在经过 Lexer 之后，剔除了无用的部分(如换行、空格等)，形成了一个token.t 列表。Parser 遍历 token 流，判断某一部分 token是否能组成正确的语言结构，并把他们抽象为一个结点。将不同的结点分层，最终组成一棵抽象语法树(AbstractSyntax Tree, AST)。</p><p>线性的 token流失去了源码的结构性，很难处理嵌套的子结构及分支结构等。AST的树形结构天然具有递归性，能很容易的进行递归甚至回溯，是更符合机器体质的数据结构。</p><p>一般来说，语法错误都是在 Parse 阶段判断的，在生成 AST之后，编译器只保留了程序的语义结构，但省略了具体的语法细节(如分号、括号)，因此称为“抽象”语法树。本质上 Lexer 和 Parser都是对源代码的抽象，最终保留下来核心的语义信息交给后续部分生成 AssemblyCode。</p><h2 id="ast-的一个例子">AST 的一个例子</h2><p>考虑如下的 <code>if-statement</code> 语句。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">if</span> (a &lt; b) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> + <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>其对应的 AST 中，根节点表示整个 <code>if</code>语句，并有两个子节点：</p><ul><li>左子树: The condition <code>a &lt; b</code></li><li>右子树: The statement <code>return 2 + 2</code></li></ul><p>我们还可以对每个子节点定义更细致的孙结点:表达式、二元运算符、左操作数、右操作数等。上述 <code>if</code>语句的完整 AST 见下图：</p><p><imgsrc="/img/write_a_c_compiler/Chapter_1/2026-01-16_17_06_46.png" /></p><p>对于本章给出的 C 程序 <code>return_2.c</code>，它的 AST会更加简单。如下图所示，这是一个线性的树型结构。</p><p><imgsrc="/img/write_a_c_compiler/Chapter_1/2026-01-17_23_13_03.png" /></p><p>AST 所保留的语义信息和源代码是同等的，即我们可以从源代码生成一棵AST，同样也可以从一棵 AST 还原回源代码。这条性质在后续 debug的时候很重要。</p><h2 id="ast-的定义">AST 的定义</h2><p>我们使用 <em>Zephyr Abstract Syntax Description Language(ASDL)</em>语言来描述一棵 AST。对于 <code>return_2.c</code>的AST，我们可以定义为如下： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ASDL">program = Program(function_definitions)<br>function_definition = Function(identifier name, statement body)<br>statement = Return(exp)<br>exp = Constant(int)<br></code></pre></td></tr></table></figure></p><p>每一行都定义了一个 AST 的结点。根节点是 <code>Program</code>结点，其子节点(或子节点们)为一个元素类型为<code>function_definition</code> 的列表的结点。但目前我们只有<code>main</code> 函数，所以只有一个子节点。一个<code>function_definition</code> 结点有两个子节点: 用于表示函数名的<code>identifier</code> 结点 和 表明语句的 <code>statement</code>结点。之后还可能新增参数节点(<code>argument node</code>)。目前我们只有<code>return</code> 语句，所以只有一种 <code>statement</code>结点，且它的唯一子节点为一个 <code>exp</code> 结点。同样，<code>exp</code> 结点只有一种，它只代表一个 <code>int</code>类型的常数。</p><p>我们可以通过 <code>|</code> 来为一类结点添加新的变体<em>constructor</em>。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ASDL">statement = Return(exp) | If(exp condition, statement then, statement? else)<br></code></pre></td></tr></table></figure><p>此时 <em>statement</em> 的值可以为<code>Return</code> 或<code>If</code>。若为 <code>If</code>结点时，有3个子节点，分别为表明判断条件的 <code>exp</code>结点，条件满足时候的执行的 <code>statement</code> 结点，和不满足时执行的<code>statement</code> 结点。<code>statement?</code> 中的 <code>?</code>表明此子节点是可选的，因为不是所有的 <code>if</code> 语句都有<code>else</code>。</p><h2 id="形式文法-formal-grammar">形式文法 (Formal Grammar)</h2><p>上述 ASDL 语句只定义了每个结点所包含的信息，我们还需要一套从<strong>token</strong> 序列构建 <strong>AST</strong> 的规则。比如<code>return</code> 语句结束时必须跟着一个<code>;</code>，函数体必须包裹在 <code>&#123;&#125;</code>中等等。这套规则我们叫作 <strong>形式文法(Formal Grammar)</strong>。对于 <code>return_2.c</code> 的 AST，每种结点所对应的形式文法如下：<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs EBNF">&lt;program&gt; ::= &lt;function&gt;<br>&lt;function&gt; ::= <span class="hljs-string">&quot;int&quot;</span> &lt;identifier&gt; <span class="hljs-string">&quot;(&quot;</span> <span class="hljs-string">&quot;void&quot;</span> <span class="hljs-string">&quot;)&quot;</span> <span class="hljs-string">&quot;&#123;&quot;</span> &lt;statement&gt; <span class="hljs-string">&quot;&#125;&quot;</span><br>&lt;statement&gt; ::= <span class="hljs-string">&quot;return&quot;</span> &lt;exp&gt; <span class="hljs-string">&quot;;&quot;</span><br>&lt;exp&gt; ::= &lt;int&gt;<br>&lt;identifier&gt; ::= <span class="hljs-meta">? An identifier token ?</span><br>&lt;int&gt; ::= <span class="hljs-meta">? A constant token ?</span><br></code></pre></td></tr></table></figure></p><p>本文采用 <em>extended Backus-Naur form (EBNF) </em>记号，每一行都是一条产生式规则 (productioinrule)，用于定义一个语言结构如何由其他语言结构和 token 组成。用<code>&lt;&gt;</code> 括起来的符号叫作 <strong>非终结符(non-terminalsymbols)</strong>，而单一的 token 称作 <strong>终结符(terminalsymbols)</strong>。非终结符可以在产生式左侧出现、并可被进一步替换或展开的符号。它们不代表语言中的实际字符或词法单元，而是代表语法结构的抽象类别。由于<em>identifier</em> 和 <em>int</em> 在源代码中并不是固定的，我们使用两个<code>?</code> 将其包裹起来。</p><p>在上述定义中，<code>&lt;function&gt;</code>后的语句规定了，一个合法的函数定义必须包括: 一个 <code>int</code> 类型的token，后跟着一个 <code>Identifier</code> 类型的 token，再后面是左括号、<code>void</code>、右括号等等。只要有一段 token序列满足这个定义，就可以将其合成为一个 <code>function</code> 结点。</p><p>如果我们想对非终结符 <code>statement</code> 增加一类 <code>if</code>语句，可以通过如下的产生式规则来定义其语法。<code>[]</code>表示可选部分。 <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs EBNF">&lt;statement&gt; ::= <span class="hljs-string">&quot;return&quot;</span> &lt;exp&gt; <span class="hljs-string">&quot;;&quot;</span> <br>               | <span class="hljs-string">&quot;if&quot;</span> <span class="hljs-string">&quot;(&quot;</span> &lt;exp&gt; <span class="hljs-string">&quot;)&quot;</span> &lt;statement&gt; [ <span class="hljs-string">&quot;else&quot;</span> &lt;statement&gt; ]<br></code></pre></td></tr></table></figure></p><h2 id="递归下降解析-recursive-descen-parsing">递归下降解析 (RecursiveDescen Parsing)</h2><p>RDP 是一种自顶向下的语法分析方法，通过为文法中的每个<strong>非终结符</strong> 编写一个对应的 token 转换函数来实现对输入token 流的解析。</p><p>更详细的描述为： 给定一组形式文法，递归下降解析器为每个非终结符 <spanclass="math inline">\(A\)</span> 构造一个解析器<code>parse_A()</code>。该解析器：</p><ul><li>读取当前输入流中的词法单元（token）；</li><li>根据文法中 <span class="math inline">\(A\)</span>的产生式规则，决定使用哪一条规则进行展开；</li><li>递归调用其他非终结符对应的解析器，直至语句解析完毕，或 token消耗完毕；</li><li>若解析成功，则消耗相应 token，并生成对应的 AST结点；若失败，则可报错或回溯。</li></ul><p>例如，对于 <code>return_2.c</code> 的 Parser，解析<code>statement</code> 语句可为如下伪代码： <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">parse_statement</span><span class="hljs-params">(tokens)</span></span>:<br>    <span class="hljs-built_in">expect</span>(<span class="hljs-string">&quot;return&quot;</span>, tokens)<br>    return_val = <span class="hljs-built_in">parse_exp</span>(tokens)<br>    <span class="hljs-built_in">expect</span>(<span class="hljs-string">&quot;;&quot;</span>, tokens)<br>    return <span class="hljs-built_in">Return</span>(return_val)<br><br><span class="hljs-function"><span class="hljs-title">expect</span><span class="hljs-params">(expected, tokens)</span></span>:<br>    actual = <span class="hljs-built_in">take_token</span>(tokens)<br>    <span class="hljs-keyword">if</span> actual != expected:<br>        <span class="hljs-built_in">fail</span>(<span class="hljs-string">&quot;Syntax error&quot;</span>)<br></code></pre></td></tr></table></figure>当这个位置期待有一条 <em>statement</em> 时，我们调用<code>parse_statement</code> 解析器。根据形式文法，<em>statement</em>需要由三部分组成：<code>return</code> 关键字，一个 <em>exp</em>符号，以及一个 <code>;</code>。通过复杂函数 <code>expect</code>判断下一个 token 是否是 <code>Return</code>，之后递归的调用<code>parse_exp</code> 来解析 <code>exp</code>符号。这也是这种解析方法被称为 ”递归下降“ 的原因。由于<code>program</code> 结点中包括了所有的<code>function_definition</code>，同时也理应包括了所有的<code>exp</code>，所以调用 <code>parse_program</code>就能递归的解析完所有的产生式规则，并生成对应的 AST。</p><p>当一个 AST 结点可由多条产生式规则生成时(如 <code>return</code> 和<code>if</code> 都对应一个 <code>statement</code>结点)，可以根据首部的几个 token决定使用哪条路径，或可以采用回溯的方法枚举所有的规则。</p><h2 id="implementation">Implementation</h2><p>首先定义 <code>ast</code> 结点。每类结点使用一个枚举体即可：<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ocaml"><span class="hljs-keyword">type</span> exp = <span class="hljs-type">Constant</span> <span class="hljs-keyword">of</span> <span class="hljs-built_in">int</span><br><span class="hljs-keyword">type</span> statement = <span class="hljs-type">Return</span> <span class="hljs-keyword">of</span> exp<br><span class="hljs-keyword">type</span> function_definition = <span class="hljs-type">Function</span> <span class="hljs-keyword">of</span> <br>  &#123;name : <span class="hljs-built_in">string</span>; body : statement&#125;<br><br><span class="hljs-keyword">type</span> t = <span class="hljs-type">Program</span> <span class="hljs-keyword">of</span> function_definition<br></code></pre></td></tr></table></figure></p><p>可以使用 <em>流式输入</em> 来维护 token 流: <figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ocaml"><span class="hljs-keyword">let</span> take_token tokens =<br>  <span class="hljs-keyword">try</span> <span class="hljs-type">Stream</span>.next tokens <span class="hljs-keyword">with</span> <span class="hljs-type">Stream</span>.<span class="hljs-type">Failure</span> -&gt; raise <span class="hljs-type">End_of_stream</span><br><br><span class="hljs-comment">(* convert a list to a stream *)</span><br><span class="hljs-keyword">let</span> of_list lst = <span class="hljs-type">Stream</span>.of_list lst<br></code></pre></td></tr></table></figure></p><p>对于每类结点，根据产生式规则编写一个 <code>parse</code>，消耗 token并生成对应的 AST 结点 <figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs ocaml"><span class="hljs-keyword">let</span> parse_id tokens = <br>  <span class="hljs-keyword">match</span> <span class="hljs-type">Tok_stream</span>.take_token tokens <span class="hljs-keyword">with</span><br>  | <span class="hljs-type">T</span>.<span class="hljs-type">Identifier</span> x -&gt; x<br>  | other -&gt; raise_error ~expected:(<span class="hljs-type">Name</span> <span class="hljs-string">&quot;an identifier&quot;</span>) ~actual:other<br><br><span class="hljs-keyword">let</span> parse_int tokens = <br>  <span class="hljs-keyword">match</span> <span class="hljs-type">Tok_stream</span>.take_token tokens <span class="hljs-keyword">with</span><br>  | <span class="hljs-type">T</span>.<span class="hljs-type">Constant</span> c -&gt; <span class="hljs-type">Ast</span>.<span class="hljs-type">Constant</span> c<br>  | _ -&gt; raise (<span class="hljs-type">ParserError</span> <span class="hljs-string">&quot;Syntax error&quot;</span>)<br><br><span class="hljs-keyword">let</span> parse_exp tokens = <br>  parse_int tokens<br><br><span class="hljs-keyword">let</span> parse_statement tokens = <br>  <span class="hljs-keyword">let</span> _ = expect <span class="hljs-type">T</span>.<span class="hljs-type">KWReturn</span> tokens <span class="hljs-keyword">in</span><br>  <span class="hljs-keyword">let</span> return_val = parse_exp tokens <span class="hljs-keyword">in</span><br>  <span class="hljs-keyword">let</span> _ = expect <span class="hljs-type">T</span>.<span class="hljs-type">Semicolon</span> tokens <span class="hljs-keyword">in</span><br>  <span class="hljs-type">Ast</span>.<span class="hljs-type">Return</span> return_val<br><br><span class="hljs-keyword">let</span> parse_function_definition tokens = <br>  <span class="hljs-keyword">let</span> _ = expect <span class="hljs-type">T</span>.<span class="hljs-type">KWInt</span> tokens <span class="hljs-keyword">in</span><br>  <span class="hljs-keyword">let</span> fun_name = parse_id tokens <span class="hljs-keyword">in</span><br>  <span class="hljs-keyword">let</span> _ = expect <span class="hljs-type">T</span>.<span class="hljs-type">OpenParen</span> tokens <span class="hljs-keyword">in</span><br>  <span class="hljs-keyword">let</span> _ = expect <span class="hljs-type">T</span>.<span class="hljs-type">KWVoid</span> tokens <span class="hljs-keyword">in</span><br>  <span class="hljs-keyword">let</span> _ = expect <span class="hljs-type">T</span>.<span class="hljs-type">CloseParen</span> tokens <span class="hljs-keyword">in</span><br>  <span class="hljs-keyword">let</span> _ = expect <span class="hljs-type">T</span>.<span class="hljs-type">OpenBrace</span> tokens <span class="hljs-keyword">in</span><br>  <span class="hljs-keyword">let</span> statement = parse_statement tokens <span class="hljs-keyword">in</span><br>  <span class="hljs-keyword">let</span> _ = expect <span class="hljs-type">T</span>.<span class="hljs-type">CloseBrace</span> tokens <span class="hljs-keyword">in</span><br>  <span class="hljs-type">Ast</span>.<span class="hljs-type">Function</span> &#123;name=fun_name; body=statement&#125;<br><br><span class="hljs-keyword">let</span> parse_program tokens = <br>  <span class="hljs-keyword">let</span> fun_def = parse_function_definition tokens <span class="hljs-keyword">in</span><br>  <span class="hljs-keyword">if</span> <span class="hljs-type">Tok_stream</span>.is_empty tokens <span class="hljs-keyword">then</span> <span class="hljs-type">Ast</span>.<span class="hljs-type">Program</span> fun_def<br>  <span class="hljs-keyword">else</span> raise (<span class="hljs-type">ParserError</span> <span class="hljs-string">&quot;Unexpected tokens after function definition&quot;</span>)<br></code></pre></td></tr></table></figure></p><p>最后调用 <code>parse_program</code>，生成合法的AST，并检查是否还有剩余的 token 。 <figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ocaml"><span class="hljs-keyword">let</span> <span class="hljs-keyword">parser</span> tokens = <br>  <span class="hljs-keyword">try</span> <br>    <span class="hljs-keyword">let</span> token_stream = <span class="hljs-type">Tok_stream</span>.of_list tokens <span class="hljs-keyword">in</span><br>    <span class="hljs-keyword">let</span> ast = <span class="hljs-type">Private</span>.parse_program token_stream<br>  <span class="hljs-keyword">with</span> <span class="hljs-type">Tok_stream</span>.<span class="hljs-type">End_of_stream</span><br>  -&gt; raise (<span class="hljs-type">ParserError</span> <span class="hljs-string">&quot;Unexpected end of file&quot;</span>)<br></code></pre></td></tr></table></figure></p><h2 id="最后的碎碎念">最后的碎碎念</h2><p>从 AST 的构建过程就可以看出 <strong>函数式编程</strong>对处理数据结构的优越性。对于一棵树结构，我们不用维护繁琐的<code>lchild</code> 和 <code>rchild</code>指针，也不用显示指明有多少儿子。</p><p>在函数式语言中，实现一棵树型结构是通过 <strong>元组</strong>来实现的，例如对于二叉树，我们可以很简单的定义如下类型：<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ocaml"><span class="hljs-keyword">type</span> binary_tree = <br>  | <span class="hljs-type">Empty</span><br>  | <span class="hljs-type">Node</span> <span class="hljs-keyword">of</span> <span class="hljs-built_in">int</span> * binary_tree * binary_tree<br></code></pre></td></tr></table></figure></p><p>对于如下的二叉树，它的实际表示为： <figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">    <span class="hljs-number">1</span><br>   / <span class="hljs-string">\</span><br>  <span class="hljs-number">2</span>   <span class="hljs-number">3</span><br> / <span class="hljs-string">\</span><br><span class="hljs-number">4</span>   <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure> <figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ocaml"><span class="hljs-type">Node</span> (<span class="hljs-number">1</span>,<br>      <span class="hljs-type">Node</span> (<span class="hljs-number">2</span>,<br>            <span class="hljs-type">Node</span> (<span class="hljs-number">4</span>, <span class="hljs-type">Empty</span>, <span class="hljs-type">Empty</span>),<br>            <span class="hljs-type">Node</span> (<span class="hljs-number">5</span>, <span class="hljs-type">Empty</span>, <span class="hljs-type">Empty</span>)),<br>      <span class="hljs-type">Node</span> (<span class="hljs-number">3</span>, <span class="hljs-type">Empty</span>, <span class="hljs-type">Empty</span>)<br>     )<br></code></pre></td></tr></table></figure></p><p>即一个嵌套 <span class="math inline">\(3\)</span> 元组 (1, (2, (4,Empty, Empty), (5, Empty, Empty)), (3, Empty, Empty))</p><p>对于我们的 AST 也是同理，只需要几种不同的 一元组(因为目前 AST是线性的) 即可。对于 <code>program</code> 结点，包括一个<code>function_def</code> 结点。<code>function_def</code>包括一个结构体，其中的 <code>body</code> 字段包括一个<code>statement</code> 结点，而这个 <code>statement</code> 结点包括一个<code>exp</code> 结点。本质上这棵 AST 可表示为<code>program(func_def(name; body(exp(int))))</code>我们不需要频繁的维护 <code>next</code>指针，只需要将递归生成的子节点放在元组对应的阶段即可。想象一下如果用<code>cpp</code> 编写同样的 AST，需要对不同的结点定义不同类型的<code>next</code> 指针，可能还需要一系列的 抽象基类、继承、多态。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Note: 所有代码、定义、术语命名都参考 Nora Sandler 的书籍 &lt;em&gt;Write a
C Compiler&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;parser&quot;&gt;Parser&lt;/h2&gt;
&lt;p&gt;源代码在经过 L</summary>
      
    
    
    
    <category term="compiler" scheme="https://acmicpc.top/categories/compiler/"/>
    
    
    <category term="compiler" scheme="https://acmicpc.top/tags/compiler/"/>
    
  </entry>
  
  <entry>
    <title>从零开始编写 C 编译器 Chapter 1.1 | Lexer</title>
    <link href="https://acmicpc.top/2026/01/16/write_a_c_compiler/Chapter1.1-Lexer/"/>
    <id>https://acmicpc.top/2026/01/16/write_a_c_compiler/Chapter1.1-Lexer/</id>
    <published>2026-01-16T11:07:25.000Z</published>
    <updated>2026-01-18T15:07:27.872Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Note: 所有代码、定义、术语命名都参考 Nora Sandler 的书籍 <em>Write aC Compiler</em></p></blockquote><h2 id="lexer">Lexer</h2><p>Lexer 读取源代码文件，将其转换为 <strong>有序的 token列表</strong>。由于 C 语言语义不依赖缩进，所以我们不用将<em>空白字符(whitespace)</em> 视为 token，但在 <code>python</code>中需要维护。</p><p>对于上篇中提到的最简 C 程序，它的 token 列表应该长这样：</p><table><thead><tr><th>Token</th><th>Description</th></tr></thead><tbody><tr><td>int</td><td>A Keyword</td></tr><tr><td>main</td><td>An identifier, whose value is "main"</td></tr><tr><td>(</td><td>An open parenthesis</td></tr><tr><td>void</td><td>A keyword</td></tr><tr><td>)</td><td>A close parenthesis</td></tr><tr><td>{</td><td>An open brace</td></tr><tr><td>return</td><td>A keyword</td></tr><tr><td>2</td><td>A constant, whose value is “2”</td></tr><tr><td>;</td><td>A semicolon</td></tr><tr><td>}</td><td>A close brace</td></tr></tbody></table><p>术语 <em>identifier</em> 表示由 ASCII字母或下划线开头，后接任意数量字母、下划线和数字组成的字符串。<em>constant</em>表示由由一个或多个数字组成的字符串。<em>identifier</em> 和<em>constant</em>都需额外维护一个值，但其他类型不用，只用维护一个单独的符号。对于现在处理的程序，<em>constant</em>中只可能出现一个 <code>int</code> 类型的常数。</p><p>上述 token 可以通过正则表达式来进行匹配，本文采用 <em>PCRE</em>语法，所有 token 类型对应的 regex 见下表:</p><table><thead><tr><th>Token 类型</th><th>regex str</th></tr></thead><tbody><tr><td>Identifier</td><td><code>[a-zA-Z_]\w*\b</code></td></tr><tr><td>Constant</td><td><code>[0-9]+\b</code></td></tr><tr><td>Int</td><td><code>int\b</code></td></tr><tr><td>Void</td><td><code>void\b</code></td></tr><tr><td>(</td><td><code>\(</code></td></tr><tr><td>)</td><td><code>\)</code></td></tr><tr><td>{</td><td><code>\&#123;</code></td></tr><tr><td>}</td><td><code>\&#125;</code></td></tr><tr><td>;</td><td><code>;</code></td></tr></tbody></table><p>所有<code>identifier</code>、<code>constant</code>、<code>keyword</code>必须以单词边界(结束；即 <code>123;</code> 是合法常量，因为以非字符<code>\w</code> 结束。但 <code>123bar</code>非法：<code>123</code>和<code>bar</code>没有通过单词边界分割，应当视为一个token，但 <code>identifier</code> 不能以数字开头，<code>Constant</code>中不能出现字母。即无法找到一条规则进行匹配。</p><p>上述就是所有目前需要了解的 token 知识点，接下来我们开始实现一个最简Lexer。伪代码如下： <figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">while</span> <span class="hljs-keyword">input</span> isn&#x27;t empty:<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">input</span> starts with whitespace:<br>        <span class="hljs-keyword">trim</span> whitespace from start of <span class="hljs-keyword">input</span><br>    <span class="hljs-keyword">else</span>:<br>        find longest match at start of <span class="hljs-keyword">input</span> <span class="hljs-keyword">for</span> any regex <span class="hljs-keyword">in</span> <span class="hljs-keyword">Table</span> 1-1<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">no</span> match is found <br>            raise <span class="hljs-keyword">an</span> <span class="hljs-keyword">error</span><br>        <span class="hljs-keyword">else</span> <br>            convert matching substring into a <span class="hljs-keyword">token</span><br>            remove matching substring from start of <span class="hljs-keyword">input</span><br></code></pre></td></tr></table></figure></p><p>大概流程就是删除开头的空格，在所有的正则模式中进行匹配，找到最长匹配开头的规则。如果没找到则报错，找到了则转换为Token.t，将其插入 token 列表，删除子串，并进行下一次匹配。</p><p>首先我们定义 token type，一个枚举体完事(<code>ocaml</code>中的枚举体可以额外携带一个任意类型的值。<code>cpp</code> 中可以定义一个<code>map</code> 来进行 Token.t 到 value 的映射)： <figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ocaml"><span class="hljs-keyword">type</span> t = <br>  <span class="hljs-comment">(* tokens with contents *)</span><br>  | <span class="hljs-type">Identifier</span> <span class="hljs-keyword">of</span> <span class="hljs-built_in">string</span><br>  | <span class="hljs-type">Constant</span> <span class="hljs-keyword">of</span> <span class="hljs-built_in">int</span><br>  <span class="hljs-comment">(* Keywords *)</span><br>  | <span class="hljs-type">KWInt</span><br>  | <span class="hljs-type">KWReturn</span><br>  | <span class="hljs-type">KWVoid</span><br>  <span class="hljs-comment">(* punctuation *)</span><br>  | <span class="hljs-type">OpenParen</span><br>  | <span class="hljs-type">CloseParen</span><br>  | <span class="hljs-type">OpenBrace</span><br>  | <span class="hljs-type">CloseBrace</span><br>  | <span class="hljs-type">Semicolon</span><br></code></pre></td></tr></table></figure></p><p>之后定义匹配模式，这里使用一个 List 来维护，这样后续遍历该 List即可。添加 <code>ANCHORED</code>来进行限制，使得只能从字符串开头进行匹配。 <code>ocaml</code>没有内置的正则匹配引擎，我们使用 <code>ocaml-re</code> 库来进行匹配。<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs ocaml"><span class="hljs-keyword">type</span> match_rule = &#123;<br>  re : <span class="hljs-type">Re</span>.re; <span class="hljs-comment">(* the regex string to match a token *)</span><br>  converter : <span class="hljs-built_in">string</span> -&gt; <span class="hljs-type">Tokens</span>.t; <br>  <span class="hljs-comment">(* a handler which convert matched string to token *)</span><br>&#125;<br><br><span class="hljs-keyword">let</span> generate_rule regex_str converter = <br>  &#123;re = <span class="hljs-type">Re</span>.<span class="hljs-type">Pcre</span>.regexp ~flags:[ <span class="hljs-type">`ANCHORED</span> ] regex_str; converter&#125;<br><br><span class="hljs-keyword">let</span> match_rules = <br>  [<br>    generate_rule &#123;_|[<span class="hljs-type">A</span>-<span class="hljs-type">Za</span>-z_][<span class="hljs-type">A</span>-<span class="hljs-type">Za</span>-z0-<span class="hljs-number">9_</span>]*\b|_&#125;  convert_identifier;<br>    generate_rule &#123;_|[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]+\b|_&#125;                  convert_constant;<br>    generate_rule &#123;_|\(|_&#125;                        (convert_literal <span class="hljs-type">T</span>.<span class="hljs-type">OpenParen</span>);<br>    generate_rule &#123;_|\)|_&#125;                        (convert_literal <span class="hljs-type">T</span>.<span class="hljs-type">CloseParen</span>);<br>    generate_rule &#123;_|\&#123;|_&#125;                        (convert_literal <span class="hljs-type">T</span>.<span class="hljs-type">OpenBrace</span>);<br>    generate_rule &#123;_|\&#125;|_&#125;                        (convert_literal <span class="hljs-type">T</span>.<span class="hljs-type">CloseBrace</span>);<br>    generate_rule <span class="hljs-string">&quot;;&quot;</span>                             (convert_literal <span class="hljs-type">T</span>.<span class="hljs-type">Semicolon</span>);<br>  ]<br><br></code></pre></td></tr></table></figure></p><p>对于每种模式，单独使用一个函数来进行 <strong>string -&gt;Token.t</strong> 的转换，并将其绑定到 <code>match_rule</code> 的<code>converter</code> 字段。 <figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ocaml"><span class="hljs-comment">(* convert string to Tokens.t *)</span><br><span class="hljs-comment">(* tips 1: treat keywords like special identifiers *)</span><br><span class="hljs-keyword">let</span> convert_identifier = <span class="hljs-keyword">function</span><br>  | <span class="hljs-string">&quot;int&quot;</span>     -&gt;   <span class="hljs-type">T</span>.<span class="hljs-type">KWInt</span><br>  | <span class="hljs-string">&quot;return&quot;</span>  -&gt;   <span class="hljs-type">T</span>.<span class="hljs-type">KWReturn</span><br>  | <span class="hljs-string">&quot;void&quot;</span>    -&gt;   <span class="hljs-type">T</span>.<span class="hljs-type">KWVoid</span><br>  | other     -&gt;   <span class="hljs-type">T</span>.<span class="hljs-type">Identifier</span> other<br><br><span class="hljs-comment">(* convert string to int *)</span><br><span class="hljs-keyword">let</span> convert_constant str = <br>  <span class="hljs-keyword">try</span> <span class="hljs-type">T</span>.<span class="hljs-type">Constant</span> (int_of_string str)<br>  <span class="hljs-keyword">with</span> <span class="hljs-type">Failure</span> _ -&gt; raise (<span class="hljs-type">LexError</span> (<span class="hljs-string">&quot;Invalid constant: &quot;</span> ^ str))<br><br><span class="hljs-comment">(* convert literal characters like &quot;(&quot; or &quot;;&quot; to Tokens.t *)</span><br><span class="hljs-keyword">let</span> convert_literal tok_type _ = tok_type<br></code></pre></td></tr></table></figure></p><p>同时我们还需要维护一个当前字符串匹配成功的模式列表，单独使用一个结构体来存储<em>成功匹配的规则</em> 和 <em>成功匹配的子串</em> ： <figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ocaml"><span class="hljs-keyword">type</span> matched_string = &#123;<br>  matched_rule : match_rule; <span class="hljs-comment">(* which rule it matched *)</span><br>  matched_substring : <span class="hljs-built_in">string</span>; <span class="hljs-comment">(* substring matched with regex token_match.re *)</span><br>&#125;<br></code></pre></td></tr></table></figure></p><p>进行匹配的函数也很容易写。<code>Re.exec_opt regex_str str</code>将主串<code>str</code> 根据 模式串<code>regex_str</code>进行匹配，匹配成功返回一个列表<code>optione group</code>，<code>group</code>中存放所有匹配成功的子串。例如<code>Re.exec_opt "ABC" "ABC;ABC;ABC"</code> 返回<code>["ABC", "ABC", "ABC"]</code>。 Lexer 中只需要第一个匹配成功的token，所以通过 <code>get</code>来获取第一个匹配成功的子串。匹配失败则产生一个 <code>None</code>。<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ocaml"><span class="hljs-keyword">let</span> find_match s rule = <br>  <span class="hljs-keyword">match</span> <span class="hljs-type">Re</span>.exec_opt rule.re s <span class="hljs-keyword">with</span><br>  | <span class="hljs-type">Some</span> group -&gt;<br>      <span class="hljs-keyword">let</span> substr = <span class="hljs-type">Re</span>.<span class="hljs-type">Group</span>.get group <span class="hljs-number">0</span> <span class="hljs-keyword">in</span><br>      <span class="hljs-type">Some</span> &#123; matched_substring = substr; matched_rule = rule&#125;<br>  | <span class="hljs-type">None</span> -&gt; <span class="hljs-type">None</span><br></code></pre></td></tr></table></figure></p><p>删除字符串前面的空格同样也可以使用正则表达式来完成，匹配模式串<code>\s+</code> 即可 。<code>Re.exec_opt</code> 返回的<code>group</code> 可以通过 <code>offset</code>获得成功匹配的子串对于串首的偏移量，丢掉这部分即可。 <figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ocaml"><span class="hljs-keyword">let</span> count_leading_ws s = <br>  <span class="hljs-keyword">let</span> ws_re = <span class="hljs-type">Re</span>.<span class="hljs-type">Pcre</span>.regexp ~flags:[ <span class="hljs-type">`ANCHORED</span> ] &#123;|\s+|&#125; <span class="hljs-keyword">in</span><br>  <span class="hljs-keyword">match</span> <span class="hljs-type">Re</span>.exec_opt ws_re s <span class="hljs-keyword">with</span><br>  | <span class="hljs-type">Some</span> group -&gt; <br>      <span class="hljs-keyword">let</span> _, end_pos = <span class="hljs-type">Re</span>.<span class="hljs-type">Group</span>.offset group <span class="hljs-number">0</span> <span class="hljs-keyword">in</span><br>      <span class="hljs-type">Some</span> end_pos<br>  | <span class="hljs-type">None</span> -&gt; <span class="hljs-type">None</span><br></code></pre></td></tr></table></figure></p><p>之后就是主 Lexer 的逻辑了, 基本和伪代码的流程差不多。<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs ocaml"><span class="hljs-keyword">let</span> <span class="hljs-keyword">rec</span> lexer input = <br>  <span class="hljs-keyword">if</span> input = <span class="hljs-string">&quot;&quot;</span> <span class="hljs-keyword">then</span> <span class="hljs-literal">[]</span><br>  <span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">match</span> count_leading_ws input <span class="hljs-keyword">with</span><br>    <span class="hljs-comment">(* have whitespace front of input *)</span><br>    | <span class="hljs-type">Some</span> end_pos -&gt; lexer (<span class="hljs-type">StringUtil</span>.drop end_pos input)<br>    | <span class="hljs-type">None</span> -&gt;<br>    <span class="hljs-comment">(* match_result contains all matched_strings that matched succesfully *)</span><br>      <span class="hljs-keyword">let</span> match_result = <span class="hljs-type">List</span>.filter_map (find_match input) match_rules <span class="hljs-keyword">in</span><br>      <span class="hljs-keyword">match</span> match_result <span class="hljs-keyword">with</span><br>      <span class="hljs-comment">(* cannot match any pattern *)</span><br>      | <span class="hljs-literal">[]</span> -&gt; raise (<span class="hljs-type">LexError</span> <br>        (<span class="hljs-string">&quot;Unrecognized token at: &quot;</span> ^ <span class="hljs-type">String</span>.sub input <span class="hljs-number">0</span> (min <span class="hljs-number">10</span> (<span class="hljs-type">String</span>.length input))))<br>      | _ -&gt;<br>          <span class="hljs-keyword">let</span> longest = <br>            <span class="hljs-type">List</span>.fold_left<br>              (<span class="hljs-keyword">fun</span> acc m -&gt; <span class="hljs-keyword">if</span> <span class="hljs-type">String</span>.length m.matched_substring &gt; <span class="hljs-type">String</span>.length acc.matched_substring <span class="hljs-keyword">then</span> m <span class="hljs-keyword">else</span> acc)<br>              (<span class="hljs-type">List</span>.hd match_result)<br>              (<span class="hljs-type">List</span>.tl match_result)<br>          <span class="hljs-keyword">in</span><br>          <span class="hljs-keyword">let</span> token = longest.matched_rule.converter longest.matched_substring <span class="hljs-keyword">in</span><br>          <span class="hljs-keyword">let</span> remaining = <span class="hljs-type">StringUtil</span>.drop (<span class="hljs-type">String</span>.length longest.matched_substring)<br>            input <span class="hljs-keyword">in</span><br>          token :: (lexer remaining)<br></code></pre></td></tr></table></figure></p><p>至此一个最简单的 Lexer 就写完了，后续会逐渐增加 token的类型，最终支持整个 C 语言。在 <code>github</code>仓库中我额外编写了一个 <code>print_matches</code> 来打印整个<code>token list</code>。如果不出意外的话，对于本章的程序，应该输出如下东西：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">./main.exe return_2.c --lex<br>Int <br>Identifier <br>Characters <br>Void <br>Characters <br>Characters <br>Return <br>Constant <br>Characters <br>Characters<br></code></pre></td></tr></table></figure></p><p>和 <code>return_2.c</code> 比较一下，可以看到正确生成了对应的 tokenlist. <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Note: 所有代码、定义、术语命名都参考 Nora Sandler 的书籍 &lt;em&gt;Write a
C Compiler&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;lexer&quot;&gt;Lexer&lt;/h2&gt;
&lt;p&gt;Lexer 读取源代</summary>
      
    
    
    
    <category term="compiler" scheme="https://acmicpc.top/categories/compiler/"/>
    
    
    <category term="compiler" scheme="https://acmicpc.top/tags/compiler/"/>
    
  </entry>
  
  <entry>
    <title>从零开始编写 C 编译器 Chapter 1.0 | Introduction</title>
    <link href="https://acmicpc.top/2026/01/15/write_a_c_compiler/Chapter1.0-Introduce/"/>
    <id>https://acmicpc.top/2026/01/15/write_a_c_compiler/Chapter1.0-Introduce/</id>
    <published>2026-01-14T19:07:25.000Z</published>
    <updated>2026-01-18T14:52:10.039Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Note: 所有代码、定义、术语命名都参考 Nora Sandler 的书籍 <em>Write aC Compiler</em></p></blockquote><p>老生常谈，CPU 只能识别 ISA规定的机器码，不能识别高级语言。所以有了编译器：将高级语言翻译为机器码(特定的二进制序列)。然而，这套工作是通过一系列编译套件(或语言工具链,Language Toolchins)来实现的。</p><p>一般来说，将高级语言翻译为机器码需要经过这几个步骤： 1.预处理(Preprocess): 将源代码中以 <code>#</code> 开头的指令展开，例如<code>#include</code>、<code>#define</code>等语句。一般预处理只是简单的字符串替换。 2. 编译(Compile):将预处理过的源代码转换为汇编语言(汇编是一系列对机器码的助记符)。 3.汇编(Assemble): 将汇编语言转换为可重定位的目标文件。 4. 链接(Linker):将一系列目标文件按照特定的规则装载为一个目标文件，并规定加载到内存的位置。</p><p>本系列文章都将聚焦 <strong>编译(Compiler)</strong> 这个过程。</p><h2 id="hello-assembly">Hello Assembly</h2><p>考虑一个最简单的 <span class="math inline">\(C\)</span> 程序, 命名为<code>return_2.c</code> ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>该程序近包含一个函数，一条语句。可以通过 <code>gcc</code>命令生成汇编: <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc -S -O -fno-asynchronous-unwind-tables -fcf-protection=none return_2.c<br></code></pre></td></tr></table></figure></p><p>选项 <code>-S</code>指明只需要进行到编译阶段，需要后续的汇编及链接。选项 <code>-O</code>表明启用编译器优化。选项 <code>-fno-asynchronous-unwind-tables</code>表明禁用调试所需要的 <code>unwind</code>表，这能大大化简我们生成的汇编文件。选项<code>-fcf-protection=none</code> 表明禁用控制流保护，减少无关指令。</p><p>在 <code>return_2.s</code> 中可以大致看到如下几条语句：<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">    .globl main<br><span class="hljs-symbol">main:</span><br>    movl $<span class="hljs-number">2</span>, %eax<br>    <span class="hljs-keyword">ret</span><br></code></pre></td></tr></table></figure></p><ul><li><code>.globl main</code>: 汇编器指令(assembler directive), 表明<code>main</code> 为全局符号，所有一同编译的 <code>.s</code>文件都应识别到 <code>main</code> 的符号，供后续连接器使用。</li><li><code>main:</code>: 标签(label), 定义 <code>main:</code>之后第一条语句所存储的地址(即 <code>movl</code> 指令的地址)。</li><li><code>movl $2, %eax</code>: 将立即数 <spanclass="math inline">\(2\)</span> 移入 <spanclass="math inline">\(32\)</span> 位寄存器<code>%eax</code>。<code>l</code> 后缀表明操作数类型为<code>long word</code>，即 <span class="math inline">\(32\)</span>位类型。根据 x86_64 调用规定，函数返回值通过 <code>%eax</code> 或<code>%rax</code> 寄存器传递。</li><li><code>ret</code>: 返回到执行 <code>main</code> 之前的指令。由于<code>main</code> 为 C 程序的入口，实际返回到 C运行时库(用于初始化或结束一个 C 进程)。</li></ul><p>通过下列指令链接并运行： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc return_2.s -o return_2<br>./return_2<br><span class="hljs-built_in">echo</span> $?<br>2<br></code></pre></td></tr></table></figure></p><p>在 shell 中, <code>$?</code> 用于获取上一进程的退出状态码。可以看到shell 中应该输出了一个 <spanclass="math inline">\(2\)</span>。通过上述的汇编我们可以知道，程序只是简单的把<span class="math inline">\(2\)</span> 放到了 <code>%eax</code>寄存器中，为什么能得到退出码呢？</p><p>在高级语言的概念中，<code>main</code>是程序执行的第一条语句，但是在操作系统和编译器的视角里，第一条指令是<strong>C运行时环境 (C Runtime 0, aka cr0)</strong> 中的启动部分。</p><p>通过 <code>objdump -d return_2</code>查看机器码，可以看到类似如下的输出: <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0000000000001000</span> &lt;_init&gt;:<br>    <span class="hljs-attribute">1000</span>:f3 <span class="hljs-number">0</span>f <span class="hljs-number">1</span>e fa          endbr64<br>    <span class="hljs-attribute">1004</span>:<span class="hljs-number">48</span> <span class="hljs-number">83</span> ec <span class="hljs-number">08</span>          sub    $<span class="hljs-number">0</span>x8,%rsp<br>    <span class="hljs-attribute">1008</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">05</span> c1 <span class="hljs-number">2</span>f <span class="hljs-number">00</span> <span class="hljs-number">00</span> mov    <span class="hljs-number">0</span>x2fc1(%rip),%rax        # <span class="hljs-number">3</span>fd0 &lt;__gmon_start__@Base&gt;<br>    <span class="hljs-attribute">100f</span>:<span class="hljs-number">48</span> <span class="hljs-number">85</span> c0             test   %rax,%rax<br>    <span class="hljs-attribute">1012</span>:<span class="hljs-number">74</span> <span class="hljs-number">02</span>                je     <span class="hljs-number">1016</span> &lt;_init+<span class="hljs-number">0</span>x16&gt;<br>    <span class="hljs-attribute">1014</span>:ff d0                call   *%rax<br>    <span class="hljs-attribute">1016</span>:<span class="hljs-number">48</span> <span class="hljs-number">83</span> c4 <span class="hljs-number">08</span>          add    $<span class="hljs-number">0</span>x8,%rsp<br>    <span class="hljs-attribute">101a</span>:c3                   ret<br><br><span class="hljs-attribute">Disassembly</span> of section .text:<br><br><span class="hljs-attribute">0000000000001020</span> &lt;_start&gt;:<br><br><span class="hljs-comment"># ... 省略一点东西</span><br><br><span class="hljs-attribute">0000000000001119</span> &lt;main&gt;:<br>    <span class="hljs-attribute">1119</span>:b8 <span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>x2,%eax<br>    <span class="hljs-attribute">111e</span>:c3                   ret<br><br><span class="hljs-attribute">Disassembly</span> of section .fini:<br><span class="hljs-attribute">0000000000001120</span> &lt;_fini&gt;:<br>    <span class="hljs-attribute">1120</span>:f3 <span class="hljs-number">0</span>f <span class="hljs-number">1</span>e fa          endbr64<br>    <span class="hljs-attribute">1124</span>:<span class="hljs-number">48</span> <span class="hljs-number">83</span> ec <span class="hljs-number">08</span>          sub    $<span class="hljs-number">0</span>x8,%rsp<br>    <span class="hljs-attribute">1128</span>:<span class="hljs-number">48</span> <span class="hljs-number">83</span> c4 <span class="hljs-number">08</span>          add    $<span class="hljs-number">0</span>x8,%rsp<br>    <span class="hljs-attribute">112c</span>:c3                   ret<br></code></pre></td></tr></table></figure></p><p>可以看到，虽然 C 程序只定义了 <code>main</code>,但是还有很多其他的部分被集成在了 <code>return_2</code>中。<code>cr0</code> 在 C程序启动前初始化最基础的运行环境，初始化堆栈、调用 <code>main</code>程序，并在程序运行结束后 调用 <code>exit</code> 将程序结束状态(即<code>main</code> 函数的返回值)传递给操作系统。由于 <code>cr0</code>是其他的汇编文件，因此 <code>main</code> 必须是全局符号，否则<code>cr0</code> 无法正确调用。</p><p>为了能存储所有文件中的符号，还需要维护一张 <strong>符号表</strong>,用于指明符号名、是否全局、所在段、偏移量等。在 Linux 系统上可以通过<code>readelf -a return_2</code> 查看可执行文件的符号表。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Symbol</span> table &#x27;.symtab&#x27; contains <span class="hljs-number">35</span> entries:<br>   <span class="hljs-attribute">Num</span>:    Value          Size Type    Bind   Vis      Ndx Name<br>     <span class="hljs-attribute">0</span>: <span class="hljs-number">0000000000000000</span>     <span class="hljs-number">0</span> NOTYPE  LOCAL  DEFAULT  UND <br>     <span class="hljs-attribute">1</span>: <span class="hljs-number">0000000000000000</span>     <span class="hljs-number">0</span> FILE    LOCAL  DEFAULT  ABS Scrt1.o<br>     <span class="hljs-attribute">2</span>: <span class="hljs-number">0000000000002048</span>    <span class="hljs-number">32</span> OBJECT  LOCAL  DEFAULT   <span class="hljs-number">16</span> __abi_tag<br>     <span class="hljs-attribute">3</span>: <span class="hljs-number">0000000000000000</span>     <span class="hljs-number">0</span> FILE    LOCAL  DEFAULT  ABS crtbeginS.o<br>     <span class="hljs-attribute">4</span>: <span class="hljs-number">0000000000001050</span>     <span class="hljs-number">0</span> FUNC    LOCAL  DEFAULT   <span class="hljs-number">11</span> deregister_tm_clones<br>     <span class="hljs-attribute">5</span>: <span class="hljs-number">0000000000001080</span>     <span class="hljs-number">0</span> FUNC    LOCAL  DEFAULT   <span class="hljs-number">11</span> register_tm_clones<br>     <span class="hljs-attribute">6</span>: <span class="hljs-number">00000000000010</span>c0     <span class="hljs-number">0</span> FUNC    LOCAL  DEFAULT   <span class="hljs-number">11</span> __do_global_dtors_aux<br>     <span class="hljs-attribute">7</span>: <span class="hljs-number">0000000000004010</span>     <span class="hljs-number">1</span> OBJECT  LOCAL  DEFAULT   <span class="hljs-number">23</span> completed.<span class="hljs-number">0</span><br>     <span class="hljs-attribute">8</span>: <span class="hljs-number">0000000000003</span>e18     <span class="hljs-number">0</span> OBJECT  LOCAL  DEFAULT   <span class="hljs-number">18</span> __do_global_dtor[...]<br>     <span class="hljs-attribute">9</span>: <span class="hljs-number">0000000000001110</span>     <span class="hljs-number">0</span> FUNC    LOCAL  DEFAULT   <span class="hljs-number">11</span> frame_dummy<br>    <span class="hljs-attribute">10</span>: <span class="hljs-number">0000000000003</span>e10     <span class="hljs-number">0</span> OBJECT  LOCAL  DEFAULT   <span class="hljs-number">17</span> __frame_dummy_in[...]<br>    <span class="hljs-attribute">11</span>: <span class="hljs-number">0000000000000000</span>     <span class="hljs-number">0</span> FILE    LOCAL  DEFAULT  ABS return_2.c<br>    <span class="hljs-attribute">12</span>: <span class="hljs-number">0000000000000000</span>     <span class="hljs-number">0</span> FILE    LOCAL  DEFAULT  ABS crtendS.o<br>    <span class="hljs-attribute">13</span>: <span class="hljs-number">0000000000002044</span>     <span class="hljs-number">0</span> OBJECT  LOCAL  DEFAULT   <span class="hljs-number">15</span> __FRAME_END__<br>    <span class="hljs-attribute">14</span>: <span class="hljs-number">0000000000000000</span>     <span class="hljs-number">0</span> FILE    LOCAL  DEFAULT  ABS <br>    <span class="hljs-attribute">15</span>: <span class="hljs-number">0000000000003</span>e20     <span class="hljs-number">0</span> OBJECT  LOCAL  DEFAULT   <span class="hljs-number">19</span> _DYNAMIC<br>    <span class="hljs-attribute">16</span>: <span class="hljs-number">0000000000002004</span>     <span class="hljs-number">0</span> NOTYPE  LOCAL  DEFAULT   <span class="hljs-number">14</span> __GNU_EH_FRAME_HDR<br>    <span class="hljs-attribute">17</span>: <span class="hljs-number">0000000000003</span>fe8     <span class="hljs-number">0</span> OBJECT  LOCAL  DEFAULT   <span class="hljs-number">21</span> _GLOBAL_OFFSET_TABLE_<br>    <span class="hljs-attribute">18</span>: <span class="hljs-number">0000000000000000</span>     <span class="hljs-number">0</span> FUNC    GLOBAL DEFAULT  UND __libc_start_mai[...]<br>    <span class="hljs-attribute">19</span>: <span class="hljs-number">0000000000000000</span>     <span class="hljs-number">0</span> NOTYPE  WEAK   DEFAULT  UND _ITM_deregisterT[...]<br>    <span class="hljs-attribute">20</span>: <span class="hljs-number">0000000000004000</span>     <span class="hljs-number">0</span> NOTYPE  WEAK   DEFAULT   <span class="hljs-number">22</span> data_start<br>    <span class="hljs-attribute">21</span>: <span class="hljs-number">0000000000004010</span>     <span class="hljs-number">0</span> NOTYPE  GLOBAL DEFAULT   <span class="hljs-number">22</span> _edata<br>    <span class="hljs-attribute">22</span>: <span class="hljs-number">0000000000001120</span>     <span class="hljs-number">0</span> FUNC    GLOBAL HIDDEN    <span class="hljs-number">12</span> _fini<br>    <span class="hljs-attribute">23</span>: <span class="hljs-number">0000000000004000</span>     <span class="hljs-number">0</span> NOTYPE  GLOBAL DEFAULT   <span class="hljs-number">22</span> __data_start<br>    <span class="hljs-attribute">24</span>: <span class="hljs-number">0000000000000000</span>     <span class="hljs-number">0</span> NOTYPE  WEAK   DEFAULT  UND __gmon_start__<br>    <span class="hljs-attribute">25</span>: <span class="hljs-number">0000000000004008</span>     <span class="hljs-number">0</span> OBJECT  GLOBAL HIDDEN    <span class="hljs-number">22</span> __dso_handle<br>    <span class="hljs-attribute">26</span>: <span class="hljs-number">0000000000002000</span>     <span class="hljs-number">4</span> OBJECT  GLOBAL DEFAULT   <span class="hljs-number">13</span> _IO_stdin_used<br>    <span class="hljs-attribute">27</span>: <span class="hljs-number">0000000000004018</span>     <span class="hljs-number">0</span> NOTYPE  GLOBAL DEFAULT   <span class="hljs-number">23</span> _end<br>    <span class="hljs-attribute">28</span>: <span class="hljs-number">0000000000001020</span>    <span class="hljs-number">38</span> FUNC    GLOBAL DEFAULT   <span class="hljs-number">11</span> _start<br>    <span class="hljs-attribute">29</span>: <span class="hljs-number">0000000000004010</span>     <span class="hljs-number">0</span> NOTYPE  GLOBAL DEFAULT   <span class="hljs-number">23</span> __bss_start<br>    <span class="hljs-attribute">30</span>: <span class="hljs-number">0000000000001119</span>     <span class="hljs-number">6</span> FUNC    GLOBAL DEFAULT   <span class="hljs-number">11</span> main<br>    <span class="hljs-attribute">31</span>: <span class="hljs-number">0000000000004010</span>     <span class="hljs-number">0</span> OBJECT  GLOBAL HIDDEN    <span class="hljs-number">22</span> __TMC_END__<br>    <span class="hljs-attribute">32</span>: <span class="hljs-number">0000000000000000</span>     <span class="hljs-number">0</span> NOTYPE  WEAK   DEFAULT  UND _ITM_registerTMC[...]<br>    <span class="hljs-attribute">33</span>: <span class="hljs-number">0000000000000000</span>     <span class="hljs-number">0</span> FUNC    WEAK   DEFAULT  UND __cxa_finalize@G[...]<br>    <span class="hljs-attribute">34</span>: <span class="hljs-number">0000000000001000</span>     <span class="hljs-number">0</span> FUNC    GLOBAL HIDDEN    <span class="hljs-number">10</span> _init<br></code></pre></td></tr></table></figure><p>同时可以注意到，程序还将数据分成了不同的段进行维护:</p><ul><li><code>.text</code>: 存放用户编写的机器指令(main 位于此段，且偏移量为<span class="math inline">\(0\)</span>)。</li><li><code>.data</code>: 存放已初始化的全局变量</li><li><code>.bss</code>: 存放未初始化的全局变量。上述两个段通常也被叫作堆区。</li><li><code>.rodata</code>:存放只读数据，<code>const</code>修饰的变量，字面量等都存放在这个区域。</li><li><code>.stack</code>:存放局部变量和临时变量，同时用于存储函数调用时需要的函数栈帧。也被叫作栈区。</li></ul><p>在不同的目标文件中(例如 <code>return_2.o</code> 和标准库<code>glibc.so</code>)，各自符号的地址都是从 <spanclass="math inline">\(0\)</span>开始，链接器需要将它们的相对地址替换为合适的绝对地址，并把符号表合并为一张总表，这个过程称为<strong>重定位</strong>。</p><h2 id="compiler-driver">Compiler Driver</h2><p>正如前面所说，将源代码转换为机器码包括 <spanclass="math inline">\(4\)</span>个阶段。其中的编译阶段还包括几个过程：</p><ul><li>Lex:词法分析器(Lexer)将源文件中的空格、制表符等无关东西删除，并将源文件中的词元(Token，由于这东西实在无法在中文中找到意思相近的词，后面都将使用单词token)分类为关键字、常量、标识符等，最终生成一个 tokens 列表。</li><li>Parse: 解析器(Parser)将得到的 tokens list 转换为一棵<strong>抽象语法树(Abstract Syntax Tree,AST)</strong>，该树以一种易于遍历和分析的形式表示源程序。上述两过程一般称为<strong>编译器的前端</strong>。</li><li>Code generate: 通过分析 AST，生成对应的汇编代码。在某些复杂的语言中，还会有一个阶段生成中间表示(InnerRepresent)代码，是一种脱离于 ISA 结构的类汇编代码。在 IR的基础上进行代码优化、安全分析等过程，最后再根据 IR生成对应目标平台的汇编代码。 这一过程也称为<strong>编译器的后端</strong>。</li></ul><p>真正的编译器应该自动完成上述的几个阶段,而不需用户手动调用一个又一个的工具。执行这个功能的组建就是 CompilerDriver。Compiler Driver是负责协调和调用编译工具链中各个组件的程序。它本身不执行实际的编译工作（如词法分析、语法分析、代码生成等），而是作为一个“调度器”或“胶水层”，按正确顺序调用预处理器、编译器、汇编器和链接器，并自动将常用的编译选项传递给各工具。上述调用的<code>gcc</code> 或 <code>clang</code> 实际都是 CompilerDriver，实际的编译器、汇编器、连接器分别叫作<code>cc</code>、<code>as</code>、<code>ld</code>。</p><p>编写编译器的第一步，是编写 CompilerDriver。为了方便后续的单元测试和调试，我们的 Compiler Driver需要满足这几个功能: 1. 调用<code>gcc -E -P INPUT_FILE -o PREPROCESSED_FILE</code> 生成预处理文件。2. 对于自己实现的编译器，需要支持<code>--lex</code>、<code>--parse</code>、<code>--codegen</code>这3个参数，使得能在这几个阶段停下，而不进行后续的操作。3. 调用 <code>gcc ASSEMBLY_FILE -o OUTPUT_FILE</code>生成最终可执行文件。 4. 可选但推荐: 支持 <code>--debug</code>选项，保留生成的预处理文件、汇编文件。</p><p>最终的 Driver 应该这样工作： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 用户输入</span><br>./main.exe hello.c<br><br><span class="hljs-comment"># 驱动内部执行</span><br>1. gcc -E -P hello.c -o hello.i<br>2. ./compiler hello.i -o hello.s  <span class="hljs-comment"># 可选 --lex --parse --codegen</span><br>3. gcc hello.s -o hello<br>4. <span class="hljs-built_in">rm</span> hello.i hello.s<br></code></pre></td></tr></table></figure></p><p>首先定义 <code>setting</code> 模块维护 <strong>目标平台</strong> 和<strong>编译选项</strong>。 <figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ocaml"><span class="hljs-keyword">type</span> stage = <span class="hljs-type">Lex</span> | <span class="hljs-type">Parse</span> | <span class="hljs-type">Codegen</span> | <span class="hljs-type">Assembly</span> | <span class="hljs-type">Executable</span><br><span class="hljs-keyword">type</span> target = <span class="hljs-type">OS_X</span> | <span class="hljs-type">Linux</span><br><br><span class="hljs-keyword">let</span> platform = <span class="hljs-built_in">ref</span> <span class="hljs-type">Linux</span> <span class="hljs-comment">(* default to Linux *)</span><br></code></pre></td></tr></table></figure></p><p>对于编译 <code>--lex</code> 等参数的实现，可以采用十分不优雅的<code>if</code> 塔来实现: <figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ocaml"><span class="hljs-keyword">let</span> compile stage src_file =<br>  <span class="hljs-keyword">let</span> source = <span class="hljs-type">In_channel</span>.with_open_text src_file <span class="hljs-type">In_channel</span>.input_all <span class="hljs-keyword">in</span><br>  <span class="hljs-comment">(* Lex it *)</span><br>  <span class="hljs-keyword">let</span> tokens = <span class="hljs-type">Lexer</span>.lexer source <span class="hljs-keyword">in</span><br>  <span class="hljs-keyword">if</span> stage = <span class="hljs-type">Settings</span>.<span class="hljs-type">Lex</span> <span class="hljs-keyword">then</span> <span class="hljs-literal">()</span><br>  <span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">let</span> ast = <span class="hljs-type">Parser</span>.<span class="hljs-keyword">parser</span> tokens <span class="hljs-keyword">in</span><br>    <span class="hljs-keyword">if</span> stage = <span class="hljs-type">Settings</span>.<span class="hljs-type">Parse</span> <span class="hljs-keyword">then</span> <span class="hljs-literal">()</span><br>    <span class="hljs-keyword">else</span> <br>      <span class="hljs-keyword">let</span> asm_ast = <span class="hljs-type">Codegen</span>.codegen ast <span class="hljs-keyword">in</span><br>      <span class="hljs-keyword">if</span> stage = <span class="hljs-type">Settings</span>.<span class="hljs-type">Codegen</span> <span class="hljs-keyword">then</span> <span class="hljs-literal">()</span><br>      <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">let</span> asm_filename = <span class="hljs-type">Filename</span>.chop_extension src_file ^ <span class="hljs-string">&quot;.s&quot;</span> <span class="hljs-keyword">in</span><br>        <span class="hljs-type">Emit</span>.emit asm_filename asm_ast<br></code></pre></td></tr></table></figure></p><p>对于<em>调用 gcc 生成执行文件</em>，通过 <code>Sys</code> 包或者用<code>python</code>、<code>bash</code> 等脚本语言简单写一个就行:<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs ocaml"><span class="hljs-keyword">let</span> run_command cmd args = <br>  <span class="hljs-keyword">if</span> <span class="hljs-type">Sys</span>.command (<span class="hljs-type">Filename</span>.quote_command cmd args) &lt;&gt; <span class="hljs-number">0</span> <span class="hljs-keyword">then</span><br>    failwith (<span class="hljs-string">&quot;Command failed: &quot;</span> ^ cmd)<br>  <br><span class="hljs-keyword">let</span> preprocess src = <br>  <span class="hljs-keyword">let</span> _ = validate_extension src <span class="hljs-keyword">in</span><br>  <span class="hljs-keyword">let</span> output = replace_extension src <span class="hljs-string">&quot;.i&quot;</span> <span class="hljs-keyword">in</span><br>  <span class="hljs-keyword">let</span> _ = run_command <span class="hljs-string">&quot;gcc&quot;</span> [<span class="hljs-string">&quot;-E&quot;</span>; <span class="hljs-string">&quot;-P&quot;</span>; src; <span class="hljs-string">&quot;-o&quot;</span>; output ] <span class="hljs-keyword">in</span><br>  output<br><br><span class="hljs-keyword">let</span> compile stage preprocess_src = <br>  <span class="hljs-keyword">let</span> _ = <span class="hljs-type">Compile</span>.compile stage preprocess_src <span class="hljs-keyword">in</span><br>  run_command <span class="hljs-string">&quot;rm&quot;</span> [ preprocess_src ];<br>  replace_extension preprocess_src <span class="hljs-string">&quot;.s&quot;</span><br><br><span class="hljs-keyword">let</span> assemble_and_link ?(cleanup = <span class="hljs-literal">true</span>) src =<br>  <span class="hljs-keyword">let</span> assembly_file = replace_extension src <span class="hljs-string">&quot;.s&quot;</span> <span class="hljs-keyword">in</span><br>  <span class="hljs-keyword">let</span> output_file = <span class="hljs-type">Filename</span>.chop_extension src <span class="hljs-keyword">in</span><br>  <span class="hljs-keyword">let</span> _ = run_command <span class="hljs-string">&quot;gcc&quot;</span> [ assembly_file; <span class="hljs-string">&quot;-o&quot;</span>; output_file ] <span class="hljs-keyword">in</span><br>  <span class="hljs-comment">(* cleanup .s files *)</span><br>  <span class="hljs-keyword">if</span> cleanup <span class="hljs-keyword">then</span> run_command <span class="hljs-string">&quot;rm&quot;</span> [ assembly_file ]<br></code></pre></td></tr></table></figure></p><p>对于 <em>解析命令行参数</em> 可以通过 <code>Cmdliner</code>包来读入用户数据。最后我们只需要一个 <code>driver</code>函数作为入口即可：</p><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ocaml"><span class="hljs-keyword">let</span> driver target debug stage src =<br>  <span class="hljs-keyword">let</span> _ = <span class="hljs-type">Settings</span>.platform := target <span class="hljs-keyword">in</span><br>  <span class="hljs-keyword">let</span> preprocessed_name = preprocess src <span class="hljs-keyword">in</span><br>  <span class="hljs-keyword">let</span> assembly_name = compile stage preprocessed_name <span class="hljs-keyword">in</span><br>  <span class="hljs-keyword">if</span> stage = <span class="hljs-type">Settings</span>.<span class="hljs-type">Executable</span> <span class="hljs-keyword">then</span><br>    assemble_and_link ~cleanup:(not debug) assembly_name<br>  <span class="hljs-keyword">else</span> <span class="hljs-literal">()</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Note: 所有代码、定义、术语命名都参考 Nora Sandler 的书籍 &lt;em&gt;Write a
C Compiler&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;老生常谈，CPU 只能识别 ISA
规定的机器码，不能识别高级语言。所以</summary>
      
    
    
    
    <category term="compiler" scheme="https://acmicpc.top/categories/compiler/"/>
    
    
    <category term="compiler" scheme="https://acmicpc.top/tags/compiler/"/>
    
  </entry>
  
  <entry>
    <title>MIT 6.S081 lab4：traps | 陷入</title>
    <link href="https://acmicpc.top/2024/02/29/MIT-6.S081-lab04/"/>
    <id>https://acmicpc.top/2024/02/29/MIT-6.S081-lab04/</id>
    <published>2024-02-29T10:20:32.000Z</published>
    <updated>2024-09-04T11:20:26.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lab4---traps">lab4 - traps</h1><h2 id="前置准备">前置准备</h2><p>主要内容为探索陷阱处理机制。</p><p>根据<ahref="https://pdos.csail.mit.edu/6.828/2021/schedule.html">课程官网</a>的要求，需要阅读完教材的第四章<spanclass="math inline">\(Page \spacetables\)</span>。并且读懂下列源代码：<code>kernel/memlayout.h</code>,<code>kernel/vm.c</code>, <code>kernel/kalloc.c</code>,<code>kernel/riscv.h</code>, <code>user/exec.c</code>。</p><p>相关笔记参考: <ahref="https://gejxd.github.io/2024/02/27/MIT-6.S081-lab04%20Notes/">lecture4 Notes</a></p><p>将<code>pgtbl</code>分支所有内容都上传仓库后，执行下列命令来切换分支<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git fetch<br>git checkout traps<br>make clean<br></code></pre></td></tr></table></figure></p><p>此外，新建一个<code>traps_dev</code>分支来进行实际实验。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout -b traps_dev<br></code></pre></td></tr></table></figure><p>在<code>traps_dev</code>中每通过一个作业的测试，提交（gitcommit）你的代码，并将所做的修改合并（git merge）到util中，然后提交（gitpush）到github。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add .<br>git commit -m <span class="hljs-string">&quot;xxxxxxxx&quot;</span><br>git checkout traps<br>git merge traps_dev<br>git push github traps:traps<br></code></pre></td></tr></table></figure><h2 id="risc-v-assembly">RISC-V assembly</h2><p>在本部分中将给出一段 RISC-V汇编代码，通过阅读代码我们要回答几个问题，并把答案存储在主目录下的<code>answers-traps.txt</code>下。</p><p>运行 <code>make fs.img</code>后会编译<code>user/call.c</code>,并生成<code>user/call.asm</code>。我们需要观察<code>call.asm</code>下的<code>g</code>、<code>f</code>、<code>main</code>函数。</p><p>RISC-V 参考文档：<ahref="https://drive.google.com/file/d/1uviu1nH-tScFfgrovvFCrj7Omv8tFtkp/view">RISC-Vunprivileged instructions</a> <ahref="https://drive.google.com/file/d/17GeetSnT5wW3xNuAHI95-SI1gPGd5sJ_/view">RISC-Vprivileged instructions</a></p><blockquote><p>哪些寄存器包含函数的参数？例如，在 <code>main</code> 调用<code>printf</code> 时，哪个寄存器保存 <spanclass="math inline">\(13\)</span>？</p></blockquote><p>查阅<code>Calling conventions</code>手册，可以发现 <spanclass="math inline">\(a_0 \rightarrowa_7\)</span>为函数参数和返回值寄存器。</p><figure><img src="/img/6.S081/Lab-04/riscv-caller.png"alt="RISC-V常用寄存器及使用约定" /><figcaption aria-hidden="true">RISC-V常用寄存器及使用约定</figcaption></figure><p>13属于第三个参数(第一个为formatstring，第二个为<code>f(8) + 1</code>)。所以存储在<spanclass="math inline">\(a_2\)</span>寄存器中。</p><blockquote><p>在 <code>main</code> 的汇编代码中，函数 <code>f</code>的调用在哪里？对 <code>g</code> 的调用在哪里？提示：编译器可能会内联函数）。</p></blockquote><p>我们先分析一下<code>g()</code>的汇编代码。 <figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">int</span> g(<span class="hljs-keyword">int</span> x) &#123;<br>   <span class="hljs-number">0</span>:<span class="hljs-number">1141</span>                addi<span class="hljs-built_in">sp</span>,<span class="hljs-built_in">sp</span>,-<span class="hljs-number">16</span><br>   <span class="hljs-number">2</span>:e406                sdra,<span class="hljs-number">8</span>(<span class="hljs-built_in">sp</span>)<br>   <span class="hljs-number">4</span>:e022                sds0,<span class="hljs-number">0</span>(<span class="hljs-built_in">sp</span>)<br>   <span class="hljs-number">6</span>:<span class="hljs-number">0800</span>                addis0,<span class="hljs-built_in">sp</span>,<span class="hljs-number">16</span><br>    return x + <span class="hljs-number">3</span><span class="hljs-comment">;</span><br>&#125;<br>   <span class="hljs-number">8</span>:<span class="hljs-number">250d</span>                addiwa0,a0,<span class="hljs-number">3</span><br><span class="hljs-symbol">   a:</span>60a2                ldra,<span class="hljs-number">8</span>(<span class="hljs-built_in">sp</span>)<br><span class="hljs-symbol">   c:</span><span class="hljs-number">6402</span>                lds0,<span class="hljs-number">0</span>(<span class="hljs-built_in">sp</span>)<br><span class="hljs-symbol">   e:</span><span class="hljs-number">0141</span>                addi<span class="hljs-built_in">sp</span>,<span class="hljs-built_in">sp</span>,<span class="hljs-number">16</span><br>  <span class="hljs-number">10</span>:<span class="hljs-number">8082</span>                <span class="hljs-keyword">ret</span><br></code></pre></td></tr></table></figure>首先将栈顶指针<code>sp</code>往下移动16字节，等价与要入栈两个元素。将<code>ra</code>，即caller进程的<code>pc</code>值，存入栈的第一个位置。将<code>s0</code>，即caller进程的其他寄存器保存地址，存放到第二个位置。</p><p>然后将<code>a0</code>的值加3，存储到<code>a0</code>寄存器中。然后从栈中恢复<code>ra</code>和<code>s0</code>的地址，此时CPU能返回原进程继续执行。然后<code>ret</code>指令将<code>a0</code>复制给原进程，即返回值。</p><p><code>f()</code>函数和<code>g()</code>大同小异，只是编译器将<code>return g(x)</code>直接展开为<code>x + 3</code>了。</p><p><code>main</code>函数中可以看到，直接将12写入<code>a1</code>，直接将13写入<code>a2</code>。所以推测直接将<code>f(8) + 1</code>计算在编译器计算出来，当常数写入了。</p><blockquote><p>printf 函数位于哪个地址？</p></blockquote><p>可以看到<code>jalr</code>跳转到了<code>ra + 1544</code>的地址，也就是<code>0x640</code>的地方。所以printf应该在这个位置。</p><blockquote><p>在 jalr 跳转至 main 函数的 printf 时，寄存器 ra 中有什么值？</p></blockquote><p>当程序进行跳转时，我们需要将 ra 寄存器存储的返回地址指向 printf执行结束后返回到主程序的位置，也就是当前位置 PC 加 4，也就是 0x38</p><h2 id="backtrace-moderate">Backtrace (moderate)</h2><h3 id="statement">Statement</h3><p>在调试过程中，回溯通常很有用：在发生错误时，堆栈上的函数调用列表。</p><blockquote><p>在 <code>kernel/printf.c</code> 中实现一个 <code>backtrace()</code>函数。在 <code>sys_sleep</code> 中插入对该函数的调用，然后运行<code>bttest</code>，调用 <code>sys_sleep</code>。输出结果如下</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">backtrace:<br>0x0000000080002cda<br>0x0000000080002bb6<br>0x0000000080002898<br></code></pre></td></tr></table></figure><blockquote><p><code>bttest</code> 之后退出<code>qemu</code>。在终端中：地址可能略有不同，但如果运行<code>addr2line -e kernel/kernel</code>（或<code>riscv64-unknown-elf-addr2line -e kernel/kernel</code>）并剪切粘贴上述地址，则如下所示：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ addr2line -e kernel/kernel<br>  0x0000000080002de2<br>  0x0000000080002f4a<br>  0x0000000080002bfc<br>  Ctrl-D<br></code></pre></td></tr></table></figure>应该查阅类似下面的内容：<code>kernel/sysproc.c:74</code>、<code>kernel/syscall.c:224</code>、<code>kernel/trap.c:85</code>。</p></blockquote><h3 id="hints">Hints</h3><ul><li>在 <code>kernel/defs.h</code> 中添加 <code>backtrace</code>原型，以便在 <code>sys_sleep</code> 中调用 <code>backtrace</code>。</li><li>GCC 编译器会将当前执行函数的帧指针存储在寄存器 s0中。将以下函数添加到 <code>kernel/riscv.h</code>,并在回溯中调用该函数来读取当前帧指针。该函数使用内联汇编读取 s0。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> uint64<br><span class="hljs-title function_">r_fp</span><span class="hljs-params">()</span><br>&#123;<br>  uint64 x;<br>  <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;mv %0, s0&quot;</span> : <span class="hljs-string">&quot;=r&quot;</span> (x) )</span>;<br>  <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><ahref="https://pdos.csail.mit.edu/6.828/2021/lec/l-riscv-slides.pdf">这些讲义</a>中有一张堆栈帧布局的图片。返回地址位于堆栈帧的帧指针的固定偏移量（-8）处，而保存的帧指针位于帧指针的固定偏移量（-16）处。</li><li>Xv6 为 xv6 内核中的每个堆栈分配一个 PAGE 对齐地址的页面。您可以使用<code>PGROUNDDOWN(fp)</code> 和 <code>PGROUNDUP(fp)</code>计算堆栈页面的顶部和底部地址（参见 <code>kernel/riscv.h</code>）。</li></ul><h3 id="analysis-solution">Analysis &amp; Solution</h3><p>前两个提示说的很明白了，这里就跳过。</p><p>首先读出<code>s0</code>寄存器的值，即当前函数的栈指针。然后用类似链表遍历的方式，每次输出<code>return address</code>的值，然后移动到<code>prev frame</code>继续遍历即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">backtrace</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;backtrace:\n&quot;</span>);<br>    uint64 fp = r_fp();<br>    <span class="hljs-keyword">while</span> (fp != PGROUNDUP(fp)) &#123;   <span class="hljs-comment">// until get to stack bottom</span><br>        <span class="hljs-comment">// get return addr in current stack frame</span><br>        uint64 ra = *(uint64*)(fp - <span class="hljs-number">8</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p\n&quot;</span>, ra);<br>        <span class="hljs-comment">// go to prev stack frame</span><br>        fp = *(uint64*)(fp - <span class="hljs-number">16</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后在<code>sys_sleep()</code>和<code>panic()</code>中调用<code>backtrace</code>。</p><p>运行结果。 <img src="/img/6.S081/Lab-04/run_backtrace.png" /> <imgsrc="/img/6.S081/Lab-04/backtrace.png" /></p><h2 id="alarm-hard">Alarm (Hard)</h2><p>咕咕咕先。说实话，题目我都没看懂().</p><p>大概就是实现 <span class="math inline">\(CPU\)</span>计时器，当一个进程使用 <span class="math inline">\(CPU\)</span>资源的时候，周期性的发出一个警告，类似于时间片轮转算法的简化版本。感觉没十几个小时弄不完，等有生之年吧。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;lab4---traps&quot;&gt;lab4 - traps&lt;/h1&gt;
&lt;h2 id=&quot;前置准备&quot;&gt;前置准备&lt;/h2&gt;
&lt;p&gt;主要内容为探索陷阱处理机制。&lt;/p&gt;
&lt;p&gt;根据&lt;a
href=&quot;https://pdos.csail.mit.edu/6.828/2021/sc</summary>
      
    
    
    
    <category term="6.S081" scheme="https://acmicpc.top/categories/6-S081/"/>
    
    
    <category term="6.S081" scheme="https://acmicpc.top/tags/6-S081/"/>
    
  </entry>
  
  <entry>
    <title>MIT 6.S081 第四章笔记 | 陷入指令和中断</title>
    <link href="https://acmicpc.top/2024/02/29/MIT-6.S081-lab04%20Notes/"/>
    <id>https://acmicpc.top/2024/02/29/MIT-6.S081-lab04%20Notes/</id>
    <published>2024-02-28T19:20:32.000Z</published>
    <updated>2024-09-03T11:37:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="isa-assembly-language">4.1 ISA &amp; Assembly Language</h2><p><span class="math inline">\(ISA\)</span>: <spanclass="math inline">\(Instruction \space Set\)</span>。</p><p><span class="math inline">\(workflow\)</span>: <spanclass="math inline">\(C \rightarrow Assembly(.S/.asm) \rightarrowbinary(object.o)\)</span></p><p>汇编语言没有明确的工作流，只是一行一行的执行指令。汇编语言是基于寄存器进行操作的，而不是内存。</p><p><span class="math inline">\(RISC-V \space vs \space x86\)</span></p><ul><li><spanclass="math inline">\(RISC-V\)</span>是精简指令集，指令数少，效率更高，不好维护。</li><li><spanclass="math inline">\(x86\)</span>：复杂指令集，指令很多并且可以实现复杂功能</li></ul><h2 id="calling-convention">4.2 Calling convention</h2><p>调用约定(<span class="math inline">\(calling \spaceconvention\)</span>)是规定子过程如何获取参数以及如何返回的方案，调用约定一般规定了:- 参数、返回值、返回地址等放置的位置(寄存器、栈或内存)。</p><p>RISC-V通过寄存器来传递参数，而不是栈。<span class="math inline">\(a_0\rightarrow a_7\)</span> 是<code>int</code>参数，<spanclass="math inline">\(f_0 \rightarrow f_7\)</span>是<code>float</code>参数。</p><ul><li>如何将调用子过程的准备工作与恢复现场的工作划分到调用者(<spanclass="math inline">\(caller\)</span>)与被调用者(<spanclass="math inline">\(callee\)</span>)身上。</li></ul><p>小于一个指针字(RISCV64中是8字节，RISCV32是4字节)的参数传入时将参数放在寄存器的最低位，因为RISC-V是小端系统，当2个指针字的参数传入时，低位的1个指针字放在偶数寄存器，比如a0上，高位的1个指针字放在奇数寄存器，比如a1上。当高于2个指针字的参数传入时以引用的方式传入。struct参数没有传到寄存器的部分将以栈的方式传入，sp栈指针将指向第一个没有传入到寄存器的参数。</p><p>从函数返回的值，如果是整数将放在a0和a1中，如果是小数将放置在fa0和fa1寄存器中。对于更大的返回值，将放置在内存中，<spanclass="math inline">\(caller\)</span>开辟这个内存，并且把指向这个内存的指针作为第一个参数传递给 <spanclass="math inline">\(callee\)</span></p><p>由 <span class="math inline">\(caller\)</span>保存的寄存器不会在函数调用之间被保存，又名易失性寄存器，如果要在过程调用后恢复该值，则调用方需要将这些寄存器压入堆栈或复制到其他位置，而<span class="math inline">\(callee\)</span>保存的寄存器会被保存，称为非易失性寄存器，可以期望这些寄存器在被调用者返回后保持相同的值。比如函数A调用了函数B，所有函数A保存的寄存器在函数B被调用后可以被B重写覆盖。</p><figure><img src="/img/6.S081/Lab-04/riscv-caller.png"alt="RISC-V常用寄存器及使用约定" /><figcaption aria-hidden="true">RISC-V常用寄存器及使用约定</figcaption></figure><h2 id="stack">4.3 Stack</h2><p>栈从高地址向低地址增长，每个大的<spanclass="math inline">\(box\)</span>叫一个<spanclass="math inline">\(stack \spaceframe\)</span>（栈帧），栈帧由函数调用来分配，每个栈帧大小不一定一样，但是栈帧的最高处一定是<spanclass="math inline">\(return \space address\)</span>。</p><p>sp是stack pointer，用于指向栈顶（低地址），保存在寄存器中</p><p>fp是framepointer，用于指向当前帧底部（高地址），保存在寄存器中，同时每个函数栈帧中保存了调用当前函数的函数（父函数）的fp（保存在toprev frame那一栏中）</p><p>这些栈帧都是由编译器编译生成的汇编文件生成的</p><figure><img src="/img/6.S081/Lab-04/riscv-stack.png" alt="RISC-V栈" /><figcaption aria-hidden="true">RISC-V栈</figcaption></figure><h2 id="trap">4.4 trap</h2><p>3种可能的情况使得CPU暂停对正常指令的执行，并强制将控制权转移到处理该事件的特殊代码：1.syscall，移交给kernel 2. exception，指令执行了非法操作 3.设备中断。以上情况合并称为trap。</p><p>trap应该对于被打断的指令是透明的，也就是说被打断的指令不应该知道这个地方产生了trap，产生trap之后现场应该得以恢复并继续执行被打断的指令。</p><p>xv6对trap的处理分为四个阶段：1. 对RISC-V CPU的硬件的一些操作 2.一些为运行kernel C语言文件做准备的汇编文件 3. 用C实现的traphandler(暂且翻译为异常处理程序) 4. system call / device-driver serviceroutine</p><p>通常对于user space的trap、kernelspace的trap和计时器中断会有不同的trap handler</p><h2 id="risc-v-trap-machinery">4.5 RISC-V trap machinery</h2><p>RISC-VCPU有一系列的控制寄存器可以通知kernel发生了trap，也可以由kernel写入来告诉CPU怎样处理trap。</p><ul><li><code>stvec</code>：异常处理程序的地址。由内核填入。</li><li><code>sepc</code>：保存trap发生时当前的<code>PC</code>寄存器值，之后<code>PC</code>的值被<code>stvec</code>覆盖。通过<code>sret</code>指令将<code>sepc</code>值也入<code>PC</code>,达到回复现场的作用。</li><li><code>scause</code>： 填入产生trap的原因，有CPU写入。</li><li><code>sscartch</code>： 异常处理程序使用的一组寄存器。</li><li><code>sstatus</code>：SIE位控制设备中断是否被开启，SPP位指示trap是来自内核还是用户程序。</li></ul><p>以上寄存器都只在监管模式被启动。</p><p>当发生除了计时器中断以外的其他类型的trap时，RISC-V将执行以下步骤：</p><ol type="1"><li>如果trap是一个设备产生的中断，而SIE又被清除的情况下，不做下方的任何动作。</li><li>清除SIE来disable一切中断。</li><li>把pc复制到sepc。</li><li>把当前的模式(user / supervisor)保存到SPP。</li><li>设置scause寄存器来指示产生trap的原因。</li><li>将当前的模式设置为supervisor。</li><li>将stvec的值复制到pc。</li><li>开始执行pc指向的trap handler的代码。</li></ol><p>注意CPU并没有切换到kernel页表，也没有切换到kernel栈,也不会保存除PC外的其他寄存器值。这些操作都应该由内核完成。</p><h2 id="traps-from-user-space">4.6 Traps from user space</h2><p>如果用户程序进行系统调用(调用<code>ecall</code>指令)、执行非法操作或者设备中断时，就会产生trap。</p><p>当userspace中发生trap时，会将<code>stvec</code>的值复制到<code>pc</code>，而此时<code>stvec</code>的值是<code>trampoline.S</code>中的<code>uservec</code>，因此跳转到<code>uservec</code>函数。该函数先保存一些现场的寄存器，恢复kernel栈指针、kernelpagetable到satp寄存器，再跳转到<code>usertrap</code>(<code>kernel/trap.c</code>)这个用户trap通用执行器。然后返回<code>usertrapret</code>(<code>kernel/trap.c</code>)，跳回到<code>kernel/trampoline.S</code>，最后用<code>userret(kernel/trampoline.S)</code>通过<code>sret</code>跳回到userspace。</p><p>RISC-V在trap中不会改变页表，因此user pagetable必须有对<code>uservec</code>的mapping，<code>uservec</code>是<code>stvec</code>指向的trapvectorinstruction。uservec要切换satp到kernel页表，同时kernel页表中也要有和user页表中对uservec相同的映射。RISC-V将<code>uservec</code>保存在<code>trampoline</code>页中，并将<code>TRAMPOLINE</code>放在kernel页表和user页表的相同位置处（MAXVA）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;isa-assembly-language&quot;&gt;4.1 ISA &amp;amp; Assembly Language&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;&#92;(ISA&#92;)&lt;/span&gt;: &lt;span
class=&quot;math inline&quot;&gt;&#92;</summary>
      
    
    
    
    <category term="6.S081" scheme="https://acmicpc.top/categories/6-S081/"/>
    
    
    <category term="6.S081" scheme="https://acmicpc.top/tags/6-S081/"/>
    
  </entry>
  
  <entry>
    <title>MIT 6.S081 第五章笔记 | 页面故障</title>
    <link href="https://acmicpc.top/2024/02/29/MIT-6.S081-lab05%20Notes/"/>
    <id>https://acmicpc.top/2024/02/29/MIT-6.S081-lab05%20Notes/</id>
    <published>2024-02-28T19:20:32.000Z</published>
    <updated>2024-09-05T06:35:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>当视图访问 <span class="math inline">\(PTE_V\)</span> 为 <spanclass="math inline">\(0\)</span> 的页表, 或用户尝试访问 <spanclass="math inline">\(PTE_U\)</span> 为 <spanclass="math inline">\(0\)</span> / 内核尝试访问 $PTE_U 为 <spanclass="math inline">\(1\)</span> 的页表， 或者是其他违反了 <spanclass="math inline">\(PTE_R\)</span> 或 <spanclass="math inline">\(PTE_W\)</span> 等 <spanclass="math inline">\(flag\)</span> 的页表时就会出现 <spanclass="math inline">\(Page Faults\)</span>。</p><p>一共有三种 <span class="math inline">\(Page Faults\)</span>: 1. <spanclass="math inline">\(load \space page \space faults\)</span>:当<code>load</code>指令无法解析虚拟地址时发生。 2. <spanclass="math inline">\(store \space page \space faults\)</span>:当<code>store</code>指令无法解析虚拟地址时发生。 3. <spanclass="math inline">\(instructions \space page \space faults\)</span>:当无法解析一条指令所在的虚拟地址时发生。</p><p><span class="math inline">\(page \space faults\)</span>种类的代码存放在<code>scause</code>寄存器中，无法翻译的地址存放在<code>stval</code>寄存器中。</p><p>在xv6中对于 <span class="math inline">\(exception\)</span>一律都会将这个进程kill掉，但是实际上可以结合<spanclass="math inline">\(page \space faults\)</span> 实现一些功能。</p><ol type="1"><li>可以实现 <span class="math inline">\(\textbf{copy-on-write} \space\textbf{fork}\)</span>。在<code>fork()</code>时，一般都是将父进程的所有<spanclass="math inline">\(user \space memory\)</span>复制到子进程中，但是<code>fork</code>之后一般会直接进行<code>exec</code>，这就会导致复制过来的<span class="math inline">\(user \space memory\)</span>又被放弃掉。因此改进的思路是：子进程和父进程共享一个物理内存，但是mapping时将PTE_W置零，只有当子进程或者父进程的其中一个进程需要向这个地址写入时产生pagefault，此时才会进行copy。</li><li>可以实现 <span class="math inline">\(\textbf{lazy} \space\testbf{allocation}\)</span>。旧的<code>sbrk()</code>申请分配内存，但是申请的这些内存进程很可能不会全部用到，因此改进方案为：当进程调用<code>sbrk()</code>时，将修改<code>p-&gt;sz</code>，但是并不实际分配内存，并且将PTE_V置0。当在试图访问这些新的地址时发生pagefault再进行物理内存的分配。</li><li><span class="math inline">\(\textbf{paging} \space \textbf{from}\space\textbf{disk}\)</span>：当内存没有足够的物理空间时，可以先将数据存储在其他的存储介质（比如硬盘）上，将该地址的PTE设置为<spanclass="math inline">\(invalid\)</span>，使其成为一个驱逐页(<spanclass="math inline">\(evictedpage\)</span>)。当需要读或者写这个PTE时，产生Pagefault，然后在内存上分配一个物理地址，将这个硬盘上的evictedpage的内容写入到该内存上，设置PTE为valid并且引用到这个内存物理地址。</li></ol><p>这两节没有什么新东西，主要就是结合前面三章的内容灵活应用，讲解一些操作系统的优化。更多在于理解为什么现代操作系统要这么设计(一个虚拟内存玩出花来了属于是)。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;当视图访问 &lt;span class=&quot;math inline&quot;&gt;&#92;(PTE_V&#92;)&lt;/span&gt; 为 &lt;span
class=&quot;math inline&quot;&gt;&#92;(0&#92;)&lt;/span&gt; 的页表, 或用户尝试访问 &lt;span
class=&quot;math inline&quot;&gt;&#92;(PTE_U&#92;</summary>
      
    
    
    
    <category term="6.S081" scheme="https://acmicpc.top/categories/6-S081/"/>
    
    
    <category term="6.S081" scheme="https://acmicpc.top/tags/6-S081/"/>
    
  </entry>
  
  <entry>
    <title>MIT 6.S081 lab3：page tables | 页表</title>
    <link href="https://acmicpc.top/2024/02/28/MIT-6.S081-lab03/"/>
    <id>https://acmicpc.top/2024/02/28/MIT-6.S081-lab03/</id>
    <published>2024-02-28T10:20:32.000Z</published>
    <updated>2024-09-03T12:22:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lab3---page-table">lab3 - page table</h1><h2 id="前置准备">前置准备</h2><p>主要内容为熟悉页表遍历以及地址转换。</p><p>根据<ahref="https://pdos.csail.mit.edu/6.828/2021/schedule.html">课程官网</a>的要求，需要阅读完教材的第三章<spanclass="math inline">\(Page \spacetables\)</span>。并且读懂下列源代码：<code>kernel/memlayout.h</code>,<code>kernel/vm.c</code>, <code>kernel/kalloc.c</code>,<code>kernel/riscv.h</code>, <code>user/exec.c</code>。</p><p>相关笔记参考: <ahref="https://gejxd.github.io/2024/02/27/MIT-6.S081-lab03%20Notes/">lecture3 Notes</a></p><p>将<code>syscall</code>分支所有内容都上传仓库后，执行下列命令来切换分支<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git fetch<br>git checkout pgtbl<br>make clean<br></code></pre></td></tr></table></figure></p><p>此外，新建一个<code>pgtbl_dev</code>分支来进行实际实验。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout -b pgtbl_dev<br></code></pre></td></tr></table></figure><p>在<code>pgtbl_dev</code>中每通过一个作业的测试，提交（gitcommit）你的代码，并将所做的修改合并（git merge）到util中，然后提交（gitpush）到github。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add .<br>git commit -m <span class="hljs-string">&quot;xxxxxxxx&quot;</span><br>git checkout pgtbl<br>git merge pgtbl_dev<br>git push github pgtbl:pgtbl<br></code></pre></td></tr></table></figure><h2 id="speed-up-system-calls-easy">Speed up system calls (easy)</h2><h3 id="statement">Statement</h3><p>在部分操作系统中，会使用用户空间和内核空间之间一块只读的共享内存来进行特定数据的共享，以此来达到加速特定的系统调用的目的，这样就消除了与内核交互产生的开销。在本部分中，我们将实现对<code>getpid()</code>系统调用的优化。</p><blockquote><p>当一个进程被创建时，映射一块只读的页面在<code>USYSCALL</code>(一个虚拟地址，定义在<code>kernel/memlayout.h</code>)。在该内存页上我们需要存储一个叫<code>struct usyscall</code>的结构体(同样定义在<code>kernel/memlayout.h</code>)，将其初始化为当前进程的<code>PID</code>。</p></blockquote><h3 id="hints">Hints</h3><ul><li>可以在<code>kernel/proc.c</code>中的<code>proc_pagetable</code>中处理内存映射问题。</li><li>注意处理访问标志位使得内存页对用户空间来说是只读的。</li><li><code>mappages()</code>在该实验中会十分有用。</li><li>不要忘记在<code>allocproc()</code>中分配和初始化<code>usyscall</code>。</li><li>确保在<code>freeproc()</code>中释放内存页。</li></ul><h3 id="analysis-solution">Analysis &amp; Solution</h3><p>先看看<code>proc_pagetable()</code>，可以看到就是用<code>mappages()</code>来将虚拟地址映射到物理地址。权限只需要设置<code>PTE_R</code>保证能读取，<code>PTE_U</code>保证用户内存能访问即可。</p><p>然后看一眼<code>allocproc()</code>,就是调用<code>kalloc()</code>来个<code>struct proc</code>里面的各个部分分配空间。</p><p>最后在看看<code>freeproc()</code>,对应把<code>allocproc</code>分配的东西，该free的free，该置0的置0。</p><p>所以我们要做的就很明显了：</p><ul><li>创建进程时，多存储一个<code>struct usyscall</code>。</li><li>创建进程页面时，将<code>struct usyscall</code>映射到<code>USYSCALL</code>。</li><li>销毁进程时，将<code>struct usyscall</code>释放，并且清空页表。</li></ul><p>在<code>struct proc</code>添加<code>struct usyscall</code>成员变量。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> &#123;</span><br>    <span class="hljs-comment">// 省略其他</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usyscall</span>* <span class="hljs-title">usyscall_info</span>;</span><br>&#125;<br></code></pre></td></tr></table></figure></p><p>然后在<code>proc_pagetable()</code>中添加映射。</p><p>NOTE：<code>uvmumap</code>要把上两次map的页面也删除。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C">proc_pagetable() &#123;<br>    <span class="hljs-comment">// 省略其他</span><br>    <span class="hljs-keyword">if</span> (mappages(pagetable, USYSCALL, PGSIZE, (uint64)(p-&gt;usyscall), PTE_R | PTR_U) &lt; ) &#123;<br>        uvmunmap(pagetable, TRAMPOLINE, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>        uvmunmap(pagetable, TRAPFRAME, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>        uvmfree(pagetable, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后在<code>allocproc</code>中分配内存，并且初始化。</p><p>NOTE：usyscall的分配要在<code>p-&gt;pagetable</code>分配前实现。不然页表会映射为空。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> proc* <span class="hljs-title function_">allocproc</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-comment">// 省略其他</span><br>    <span class="hljs-keyword">if</span> ((p-&gt;usyscall_info = (<span class="hljs-keyword">struct</span> usyscall*)kalloc()) == <span class="hljs-number">0</span>) &#123;<br>        freeproc(p);<br>        release(&amp;p-&gt;lock);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    p-&gt;usyspage-&gt;pid = p-&gt;pid;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后在<code>freeproc</code>中释放内存。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">freeproc</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> proc *)</span> &#123;<br>    <span class="hljs-comment">// 省略其他</span><br>    <span class="hljs-keyword">if</span> (p-&gt;usyscall_info) kfree((<span class="hljs-type">void</span>*)p-&gt;usyscall_info);<br>    p-&gt;usyscall_info = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>然后运行会喜提一个<code>panic: freewalk leaf</code>。翻一下<code>freewalk</code>这个函数，发现如果PTE_V没有设置，或者pte为空，就会有这个panic。<img src="/img/6.S081/Lab-03/panic.png" /></p><p>刚才只有<code>mappages</code>中修改到了页表。查看<code>mappages</code>函数的代码。由于并没有提示<code>panic：mappages remap</code>，说明PTE_V被正常设置。那问题只能是<code>freewalk</code>中的<code>pte</code>为空了。</p><p>一通检查，发现页表<code>freeproc</code>中的<code>uvmfree</code>只是把所有项都置为0，并不清空映射，所以映射出来就为空了。然后找到<code>proc_freepagetable()</code>这个函数(在<code>kernel/proc.h</code>中)，删除<code>USYSCALL</code>的映射即可。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">proc_freepagetable</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> pagetable, uint64 sz)</span> &#123;<br>    <span class="hljs-comment">// 省略其他</span><br>    uvmunmap(pagetable, USYSCALL, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure></p><p><img src="/img/6.S081/Lab-03/ugetpid.png" /></p><h2 id="print-a-page-table-easy">Print a page table (easy)</h2><h3 id="statement-1">Statement</h3><p>在本部分中，我们需要将 RISC-V的页表可视化，也就是实现一个页表内容的打印功能，作为后续调试的辅助工具。</p><blockquote><p>我们需要定义一个<code>vmprint</code>函数。该函数应该有一个参数<code>pagetable_t</code>，作为要可视化的页表，然后按下面的格式打印这个页表的信息。添加一行<code>if (p-&gt;pid == 1) vmprimt(p-&gt;pagetable)</code>在<code>exec.c</code>中，在返回<code>argc</code>之前输出第一个进程的页面信息。</p></blockquote><p>当你启动<code>xv6</code>的时候，<code>exec</code>完成内核加载时你应该会看到下面的信息：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">page table 0x0000000087f6e000<br> <span class="hljs-string">..0</span>: pte 0x0000000021fda801 pa 0x0000000087f6a000<br> <span class="hljs-string">..</span> <span class="hljs-string">..0</span>: pte 0x0000000021fda401 pa 0x0000000087f69000<br> <span class="hljs-string">..</span> <span class="hljs-string">..</span> <span class="hljs-string">..0</span>: pte 0x0000000021fdac1f pa 0x0000000087f6b000<br> <span class="hljs-string">..</span> <span class="hljs-string">..</span> <span class="hljs-string">..1</span>: pte 0x0000000021fda00f pa 0x0000000087f68000<br> <span class="hljs-string">..</span> <span class="hljs-string">..</span> <span class="hljs-string">..2</span>: pte 0x0000000021fd9c1f pa 0x0000000087f67000<br> <span class="hljs-string">..255</span>: pte 0x0000000021fdb401 pa 0x0000000087f6d000<br> <span class="hljs-string">..</span> <span class="hljs-string">..511</span>: pte 0x0000000021fdb001 pa 0x0000000087f6c000<br> <span class="hljs-string">..</span> <span class="hljs-string">..</span> <span class="hljs-string">..509</span>: pte 0x0000000021fdd813 pa 0x0000000087f76000<br> <span class="hljs-string">..</span> <span class="hljs-string">..</span> <span class="hljs-string">..510</span>: pte 0x0000000021fddc07 pa 0x0000000087f77000<br> <span class="hljs-string">..</span> <span class="hljs-string">..</span> <span class="hljs-string">..511</span>: pte 0x0000000020001c0b pa 0x0000000080007000<br></code></pre></td></tr></table></figure><p>第一行表示了 <code>vmprint</code>传入的参数，也就是页表入口的地址。接下来的每一行都是 PTE，以及 PTE下可能存在的下级页表（学过算法的都应该看出来了这是一个递归）。我们用<code>..</code>来表示这个 PTE 的深度，最开始打印的数字是这个 PTE 在一个 4KB 内存页（共512 个 PTE）的编号，接下来会打印 PTE 的具体数值。</p><h3 id="hints-1">Hints</h3><ul><li>可以把<code>vmprint</code>实现在<code>kernel/vm.c</code>文件里面。</li><li>记得使用<code>kernel/riscv.h</code>中的宏定义，包括但不限于<code>PTE2PA</code>等，来方便你转换PTE到物理地址。</li><li>如果你无从下手，记得阅读<code>freewalk</code>函数。</li><li>在<code>kernel/defs.h</code>中添加<code>vmprint</code>的原型，一遍在<code>exec.c</code>中正确调用。</li><li>在<code>print</code>中使用<code>%p</code>来打印完整的64位地址信息。</li></ul><h3 id="analysis-solution-1">Analysis &amp; Solution</h3><p>提示里面说了<code>freewalk</code>函数很重要，所以外面先读一下这个函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Recursively free page-table pages.</span><br><span class="hljs-comment">// All leaf mappings must already have been removed.</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">freewalk</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> pagetable)</span> &#123;<br>    <span class="hljs-comment">// there are 2^9 = 512 PTEs in a page table.</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">512</span>; i++) &#123;<br>        <span class="hljs-type">pte_t</span> pte = pagetable[i];<br>        <span class="hljs-keyword">if</span> ((pte &amp; PTE_V) &amp;&amp; (pte &amp; (PTE_R | PTE_W | PTE_X)) == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// this PTE points to a lower-level page table.</span><br>            uint64 child = PTE2PA(pte);<br>            freewalk((<span class="hljs-type">pagetable_t</span>)child);<br>            pagetable[i] = <span class="hljs-number">0</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pte &amp; PTE_V) &#123;<br>            panic(<span class="hljs-string">&quot;freewalk: leaf&quot;</span>);<br>        &#125;<br>    &#125;<br>    kfree((<span class="hljs-type">void</span> *)pagetable);<br>&#125;<br></code></pre></td></tr></table></figure><p>首先传入了一个页表，并且遍历里面的所有项。如果<code>pte</code>不为空并且<code>PTE_V</code>标志位为1，说明这项页面存在，并且映射了一个虚拟内存到物理内存。如果<code>PTE_R</code>、<code>PTE_R</code>、<code>PRE_X</code>都为0，说明这个页面为高级页表，读取下一级页表的地址，递归调用<code>freewalk</code>来遍历。</p><p>emmmm，然后就没什么好说的了，照着上面加点输入输出就可以。</p><p><code>vmprint</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// lab3 - exercise 2</span><br><span class="hljs-comment">// print a page table</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vmprint</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> pagetable, <span class="hljs-type">int</span> depth)</span> &#123;<br>    <span class="hljs-keyword">if</span> (depth == <span class="hljs-number">1</span>)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;page table %p\n&quot;</span>, pagetable);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">512</span>;i ++) &#123;<br>        <span class="hljs-type">pte_t</span> pte = pagetable[i];<br>        <span class="hljs-comment">// printf(&quot;%d: pte %p pa %p\n&quot;, i, pte, PTE2PA(pte));</span><br>        <span class="hljs-keyword">if</span> (pte &amp; PTE_V) &#123;<br>             <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= depth;j ++)<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;..%s&quot;</span>, j == depth ? <span class="hljs-string">&quot;&quot;</span> : <span class="hljs-string">&quot; &quot;</span>);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: pte %p pa %p\n&quot;</span>, i, pte, PTE2PA(pte));<br>            <span class="hljs-keyword">if</span> ((pte &amp; (PTE_R | PTE_W | PTE_X)) == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-type">pagetable_t</span> child = (<span class="hljs-type">pagetable_t</span>)PTE2PA(pte);<br>                vmprint((<span class="hljs-type">pagetable_t</span>)child, depth + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后在<code>kernel/defs.h</code>中添加原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// vm.c</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vmprint</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> pagetable)</span>;<br></code></pre></td></tr></table></figure><p>在<code>exec.c</code>的<code>return</code>前插入代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">if</span>(p-&gt;pid==<span class="hljs-number">1</span>) <br>    vmprint(p-&gt;pagetable);<br><span class="hljs-keyword">return</span> argc; <span class="hljs-comment">// this ends up in a0, the first argument to main(argc, argv)</span><br></code></pre></td></tr></table></figure><p><img src="/img/6.S081/Lab-03/print.png" /></p><h2 id="detecting-which-pages-have-been-accessed">Detecting which pageshave been accessed</h2><h3 id="statement-2">Statement</h3><p>一些垃圾回收器(一种自动内存管理的形式)，可以从已经被访问的内存(写或读)中获得信息。在这部分实验，你将要给xv6内核添加一个新特性，通过检查RISC-V页表中的访问页来给用户空间传递这一信息。每当RISC-V硬件解决TLB未命中问题的时候，都会在PTE的标志位中标记对应位。(即不用考虑TLB和页表潜在不同步问题)。</p><blockquote><p>你的目标是实现<code>pgaccess()</code>，一个用于报告当前进程哪些页面已被访问过的系统调用。它需要3个参数。首先，它需要第一个要检查的用户页面的起始虚拟地址。其次，它接受要检查的页面数。最后，它需要一个缓冲区的用户地址，以便将结果存储到位掩码（一种数据结构，每页使用一位，其中第一页对应的是最小有效位）中。如果在运行<code>pgtbltest</code> 时通过了 <code>pgaccess</code>测试用例，这部分实验将获得满分。</p></blockquote><h3 id="hints-2">Hints</h3><ul><li>首先在 <code>kernel/sysproc.c</code> 中实现<code>sys_pgaccess()</code>。</li><li>需要使用 <code>argaddr()</code> 和 <code>argint()</code>解析参数。</li><li>对于输出位掩码，在内核中存储一个临时缓冲区并在填入正确的位后将其拷贝给用户（通过<code>copyout()</code>）会更容易一些</li><li><code>kernel/vm.c</code> 中的 <code>walk()</code> 对于找到正确的 PTE非常有用。</li><li>需要在 <code>kernel/riscv.h</code> 中定义访问位<code>PTE_A</code>。请查阅 RISC-V 手册确定其值。</li><li>在检查 <code>PTE_A</code>是否被设置后，请务必将其清除。否则，将无法确定上次调用<code>pgaccess()</code> 后是否访问过页面（即该位将永远被设置）。</li><li><code>vmprint()</code> 可能会在调试页表时派上用场。</li></ul><h3 id="analysis-solution-2">Analysis &amp; Solution</h3><p>大概意思可能和<code>cache</code>中的脏位差不多。检测到上一次调用<code>sys_pgaccess()</code>这段时间内，哪些页表项被访问过。可能完整的UNIX 系统中会用这个信息来实现TLB和页表的同步。</p><p>需要注意的是，PTE_A位是由RISC-V硬件来维护的，在xv6中则是由<code>qemu</code>模拟器来负责维护，我们不用考虑什么时候将PTE_A置为1。</p><p>还是教材上这张图, RISC-V硬件页表的标记位： <imgsrc="/img/6.S081/Lab-03/bitmask.png" /></p><p>可以看到 <span class="math inline">\(access\)</span> 标志位是第 <spanclass="math inline">\(6\)</span> 位(从 <spanclass="math inline">\(0\)</span> 数起，从左到右)。所以在<code>kernel/riscv.h</code>下面，添加一位PTE_A的定义。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PTE_V (1L &lt;&lt; 0)   <span class="hljs-comment">// valid</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PTE_R (1L &lt;&lt; 1)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PTE_W (1L &lt;&lt; 2)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PTE_X (1L &lt;&lt; 3)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PTE_U (1L <span class="hljs-string">&lt;&lt; 4)   // 1 -&gt;</span> user can access</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PTE_A (1L &lt;&lt; 6)   <span class="hljs-comment">// Lab pgtbl: Whether it has been visited</span></span><br></code></pre></td></tr></table></figure></p><p>按照lab-2的内容看看系统调用需要添加的东西，真良心全添加好了。所以我们只用考虑怎么来实现。在<code>kernel/sysproc.c</code>中 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> LAB_PGTBL</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sys_pgaccess</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-comment">// lab pgtbl: your code here.</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure></p><p>我们用一个 <span class="math inline">\(64\)</span>位的整数来当作<code>bitmask</code>，一位表示一张页表，所以只能访问 <spanclass="math inline">\(64\)</span>张页表。即参数里的<code>pgnums</code>不能超过 <spanclass="math inline">\(64\)</span>。然后就是从用户进程页表中的<code>va</code>开始，往下访问<code>pgnums</code>张页表项，如果当前PTE的access位为1，对应的bitmask位也置为1。由于<code>sys_pgaccess()</code>也会访问页表，这个操作也会将PTE_A置为1，所以在标记完<code>bitmask</code>之后，需要将PTE_A重置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">sys_pgaccess</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-comment">// virtual address</span><br>    uint64 va;<br>    <span class="hljs-keyword">if</span> (argaddr(<span class="hljs-number">0</span>, &amp;va) &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// the number of page table to check.</span><br>    <span class="hljs-type">int</span> pgnums;<br>    <span class="hljs-keyword">if</span> (argint(<span class="hljs-number">1</span>, &amp;pgnums) &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// user virtual address</span><br>    uint64 ua;<br>    <span class="hljs-keyword">if</span> (argaddr(<span class="hljs-number">2</span>, &amp;ua) &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    uint64 bitmask = <span class="hljs-number">0</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span>* <span class="hljs-title">p</span> =</span> myproc();<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; pgnums; i++) &#123;<br>        <span class="hljs-keyword">if</span> (va &gt;= MAXVA) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-type">pte_t</span> *pte = walk(p-&gt;pagetable, va, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> ((*pte &amp; PTE_V) &amp;&amp; (*pte &amp; PTE_A)) &#123;<br>            bitmask |= (<span class="hljs-number">1</span> &lt;&lt; i);<br>            *pte ^= PTE_A;<br>        &#125;<br>        va += PGSIZE;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (copyout(p-&gt;pagetable, ua, (<span class="hljs-type">char</span>*)&amp;bitmask, <span class="hljs-keyword">sizeof</span>(bitmask)) &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后报错说<code>walk()</code>没被定义，看一眼<code>kernel/defs.h</code>，发现没有<code>walk</code>函数原型，所以添加一个即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">copyinstr</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span>, <span class="hljs-type">char</span>*, uint64, uint64)</span>;<br><span class="hljs-type">pte_t</span>* <span class="hljs-title function_">walk</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span>, uint64, <span class="hljs-type">int</span>)</span>;<br></code></pre></td></tr></table></figure><p><img src="/img/6.S081/Lab-03/sys_pgaccess.png" /></p><h2 id="submit-lab">Submit lab</h2><p>新建<code>time.txt</code>文件，输入一个整数表明完成所有实验的耗时。</p><p>运行<code>make grade</code>。 <imgsrc="/img/6.S081/Lab-03/grade.png" /></p><p>这里<code>usertests</code>会评测所有xv6的函数，耗时较长，如果用虚拟机或低配置机器的同学可以修改<code>grade-lab-pgtbl</code>里面的<code>timeout</code>，不然还没评测完就给你来一个血红色的<code>FAIL</code>。</p><p>运行<code>make handin</code>,根据提示将<code>API KEY</code>填入，提交完成。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;lab3---page-table&quot;&gt;lab3 - page table&lt;/h1&gt;
&lt;h2 id=&quot;前置准备&quot;&gt;前置准备&lt;/h2&gt;
&lt;p&gt;主要内容为熟悉页表遍历以及地址转换。&lt;/p&gt;
&lt;p&gt;根据&lt;a
href=&quot;https://pdos.csail.mit.edu</summary>
      
    
    
    
    <category term="6.S081" scheme="https://acmicpc.top/categories/6-S081/"/>
    
    
    <category term="6.S081" scheme="https://acmicpc.top/tags/6-S081/"/>
    
  </entry>
  
  <entry>
    <title>MIT 6.S081 第三章笔记 | 页表</title>
    <link href="https://acmicpc.top/2024/02/27/MIT-6.S081-lab03%20Notes/"/>
    <id>https://acmicpc.top/2024/02/27/MIT-6.S081-lab03%20Notes/</id>
    <published>2024-02-27T10:20:32.000Z</published>
    <updated>2024-08-30T12:19:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>页表让每个进程都拥有自己独立的虚拟内存，从而实现内存隔离。</p><h2 id="paging-hardware">3.1 Paging hardware</h2><p>用户和内核都只能操作虚拟地址(<span class="math inline">\(virtual\space address\)</span>)，但是实际物理内存使用物理地址(<spanclass="math inline">\(physical \spaceaddress\)</span>)来索引。页表提供了虚拟地址到逻辑地址的转换。</p><p>xv6只使用了64位地址空间中的低39位，其中高<spanclass="math inline">\(27\)</span>位为页面号，低<spanclass="math inline">\(12\)</span>位为页内偏移，即<spanclass="math inline">\(4096(2^{12})\)</span>字节一个<spanclass="math inline">\(page\)</span>，同<code>kernel/riscv.h</code>中<code>PGSIZE</code>相同，一个进程的虚拟内存可以有<spanclass="math inline">\(2^{27}\)</span>个<spanclass="math inline">\(page\)</span>，对应到<spanclass="math inline">\(2^{27}\)</span>个页表项<spanclass="math inline">\((page \space table \space entries,PTEs)\)</span>。每个<span class="math inline">\(PTE\)</span>存储<spanclass="math inline">\(44\)</span>位的物理地址和10位标记，总共<spanclass="math inline">\(54\)</span>位，即一个PTE需要8字节来存储。每个物理地址高<span class="math inline">\(44\)</span> 位是PTE中存储, 后<spanclass="math inline">\(12\)</span>位用页内偏移。一个物理地址总共用<spanclass="math inline">\(56\)</span>位表示。</p><figure><img src="/img/6.S081/Lab-03/figure3-1.png"alt="Figure 3.1: RISC-V virtual and physical addresses, with a simplified logical page table." /><figcaption aria-hidden="true">Figure 3.1: RISC-V virtual and physicaladdresses, with a simplified logical page table.</figcaption></figure><p>RISC-V页表并不是整个存储在内存中的(因为很难找到空闲的整块内存存储)，而是采用三级树结构，来使得页表空间可以动态分配和离散存储。每个页表就是一页。第一级页表是一个4096字节的页，包含了512个PTE（因为每个PTE需要8字节），每个PTE存储了下级页表的页物理地址。第二级列表由512个页构成(<spanclass="math inline">\(512 *4096字节\)</span>)，第三级列表由512*512个页构成。因为每个进程虚拟地址的高27位用来确定PTE，对应到3级页表就是最高的9位确定一级页表PTE的位置(即偏移量)，中间9位确定二级页表PTE的位置，最低9位确定三级页表PTE的位置。每一页内地址是连续的，但是不同页之间内存不一定连续。如下图所示。第一级根页表的物理地址存储在<code>satp</code>寄存器中，每个CPU核心拥有自己独立的<code>satp</code>。</p><figure><img src="/img/6.S081/Lab-03/figure3-2.png"alt="Figure 3.2: RISC-V address translation details." /><figcaption aria-hidden="true">Figure 3.2: RISC-V address translationdetails.</figcaption></figure><p>PTE flag可以告诉硬件这些相应的虚## 3.4 Physical memory allocation</p><p>xv6在运行时分配或释放页表、用户内存、内核栈、管道缓冲区等各种物理内存的不同用途。xv6中这些内存都分配在<strong>内核数据</strong>的末位和PHYSTOP之间，每次分配4096字节，即4KB空间。</p><p>分配和释放是通过对空闲页链表进行追踪完成的(<code>kernel/kalloc.c:struct kmem</code>)，分配空间就是将一个页从链表中移除，释放空间就是将一页增加到链表中。</p><p>kernel的物理空间的分配函数在<code>kernel/kalloc.c</code>中，每个页在链表中的元素是<code>struct run</code>，每个run存储在空闲页本身中。这个空闲页的链表<code>freelist</code>由<code>spin lock</code>保护，包装在<code>struct kmem</code>中。</p><ul><li><code>kinit</code>：初始化所有空闲内存列表，在内核刚启动的时候调用。从<code>kernel end</code>到<code>PHYSTOP</code>之间的所有内存都按页清空，并存放在<code>freelist</code>中。</li><li><code>freerange</code>：将range中的每一个页面都调用一次<code>free()</code>来将其插入到<code>freelist</code>的末尾。</li></ul><h2 id="进程地址空间">3.5 进程地址空间</h2><h2 id="kernel-address-space">3.2 Kernel address space</h2><p><code>QEMU</code>会模拟一块从<code>0x80000000</code>开始的内存，到至少<code>0x88000000</code>。<code>0x80000000</code>以下的地址被视为直接与设备交互，而不是内存。## 3.4 Physical memory allocation</p><p>xv6在运行时分配或释放页表、用户内存、内核栈、管道缓冲区等各种物理内存的不同用途。xv6中这些内存都分配在<strong>内核数据</strong>的末位和PHYSTOP之间，每次分配4096字节，即4KB空间。</p><p>分配和释放是通过对空闲页链表进行追踪完成的(<code>kernel/kalloc.c:struct kmem</code>)，分配空间就是将一个页从链表中移除，释放空间就是将一页增加到链表中。</p><p>kernel的物理空间的分配函数在<code>kernel/kalloc.c</code>中，每个页在链表中的元素是<code>struct run</code>，每个run存储在空闲页本身中。这个空闲页的链表<code>freelist</code>由<code>spin lock</code>保护，包装在<code>struct kmem</code>中。</p><ul><li><code>kinit</code>：初始化所有空闲内存列表，在内核刚启动的时候调用。从<code>kernel end</code>到<code>PHYSTOP</code>之间的所有内存都按页清空，并存放在<code>freelist</code>中。</li><li><code>freerange</code>：将range中的每一个页面都调用一次<code>free()</code>来将其插入到<code>freelist</code>的末尾。</li></ul><h2 id="进程地址空间-1">3.5 进程地址空间</h2><ul><li><code>trampoline page</code>在用户空间和内核空间中都在同一个虚拟地址。以便能在<code>user</code>和<code>kernel</code>间切换时方便的访问。</li><li>kernel stackpage：每个进程有一个自己的内核栈kstack，每个kstack下面有一个没有被映射的guardpage，guard page的作用是防止kstack溢出影响其他kstack。</li></ul><h2 id="code-creating-an-address-space">3.3 Code: creating an addressspace</h2><p>大多数和管理页表相关的代码都存放在<code>kernel/vm.c</code>中。核心结构体是<code>pagetable_t</code>，<strong>实际是一个指向一块8字节内存的指针</strong>(见<code>kernel/riscv.h</code>最后一行)。</p><p>重要的函数:</p><ul><li><code>walk</code>(<code>kernel/vm.c</code>):模拟RISC-V三级分页硬件。给定虚拟地址和页表，返回最终页表的PTE。</li><li><code>mappages</code>：给定一个页表，虚拟地址和物理地址，通过在页表中写入PTE来建立映射。</li><li><code>kvminit</code>：调用<code>kvmmap</code>来创建内核页表的映射。</li><li><code>kvminithart</code>：把kernel页表的物理地址写入satp寄存器。从<code>w_satp</code>这行代码后，页表开始启用，地址都变成虚拟地址。</li></ul><p>每个RISC-V CPU会把PTE缓存到<em>Translation Look-aside Buffer(TLB)</em>中，当xv6更改了页表时，必须通知CPU来取消掉当前的TLB，取消当前TLB的函数是sfence.vma()，在kvminithart中被调用</p><h2 id="physical-memory-allocation">3.4 Physical memory allocation</h2><p>xv6在运行时分配或释放页表、用户内存、内核栈、管道缓冲区等各种物理内存的不同用途。xv6中这些内存都分配在<strong>内核数据</strong>的末位和PHYSTOP之间，每次分配4096字节，即4KB空间。</p><p>分配和释放是通过对空闲页链表进行追踪完成的(<code>kernel/kalloc.c:struct kmem</code>)，分配空间就是将一个页从链表中移除，释放空间就是将一页增加到链表中。</p><p>kernel的物理空间的分配函数在<code>kernel/kalloc.c</code>中，每个页在链表中的元素是<code>struct run</code>，每个run存储在空闲页本身中。这个空闲页的链表<code>freelist</code>由<code>spin lock</code>保护，包装在<code>struct kmem</code>中。</p><ul><li><code>kinit</code>：初始化所有空闲内存列表，在内核刚启动的时候调用。从<code>kernel end</code>到<code>PHYSTOP</code>之间的所有内存都按页清空，并存放在<code>freelist</code>中。</li><li><code>freerange</code>：将range中的每一个页面都调用一次<code>free()</code>来将其插入到<code>freelist</code>的末尾。</li></ul><h2 id="user-space-address">3.5 User space address</h2><p>每个进程都有一个单独的页表，当内核在进程之间切换的时候，他也会修改对于的页表。<img src="/img/6.S081/Lab-03/figure3-4.png"alt="Figure 3.4: A process’s user address space, with its initial stack." /></p><p>当进程向内核索要更多用户内存的时候，xv6会调用<code>kalloc</code>来分配物理内存。然后会向进程页表中添加新的PTE项，并附带<code>PTE_W</code>、<code>PTE_R</code>、<code>PTR_U</code>和<code>PTE_V</code>标志。</p><p>从这里可以看到页表的几个使用好处：1.不同进程的页表将同样的用户地址映射到不同的内存中，从而每个进程都拥有独自的内存。2.每个进程的虚拟地址都一段从0开始的连续地址，但实际的物理地址并不用为连续的。3.内核将所有进程运行状态都存储在虚拟空间顶部的<code>trampoline</code>页面中(没有设置<code>PTE_U</code>权限)，防止用户进程修改其他数据。</p><h2 id="code-exec">3.6 Code : exec</h2><p>exec是一个<code>system call</code>，为以ELF格式定义的文件系统中的可执行文件创建用户空间。</p><p>exec先检查头文件中是否有<code>ELF_MAGIC</code>来判断这个文件是否是一个ELF格式定义的二进制文件，用<code>proc_pagetable</code>来为当前进程创建一个还没有映射的页表，然后用<code>uvmalloc</code>来为每个ELFsegment分配物理空间并在页表中建立映射，然后用<code>loadseg</code>来把ELFsegment加载到物理空间当中。注意<code>uvmalloc</code>分配的物理内存空间可以比文件本身要大。</p><p>接下来exec分配userstack，它仅仅分配一页给stack，通过<code>copyout</code>将传入参数的string放在stack的顶端，然后在ustack的下方分配一个<code>guard page</code></p><p>如果exec检测到错误，将跳转到bad标签，释放新创建的pagetable并返回-1。exec必须确定新的执行能够成功才会释放进程旧的页表(proc_freepagetable(oldpagetable,oldsz))，否则如果system call不成功，就无法向旧的页表返回-1</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;页表让每个进程都拥有自己独立的虚拟内存，从而实现内存隔离。&lt;/p&gt;
&lt;h2 id=&quot;paging-hardware&quot;&gt;3.1 Paging hardware&lt;/h2&gt;
&lt;p&gt;用户和内核都只能操作虚拟地址(&lt;span class=&quot;math inline&quot;&gt;&#92;(virtual</summary>
      
    
    
    
    <category term="6.S081" scheme="https://acmicpc.top/categories/6-S081/"/>
    
    
    <category term="6.S081" scheme="https://acmicpc.top/tags/6-S081/"/>
    
  </entry>
  
  <entry>
    <title>MIT 6.S081 Lab2：System Calls | 系统调用</title>
    <link href="https://acmicpc.top/2024/02/25/MIT-6.S081-lab02/"/>
    <id>https://acmicpc.top/2024/02/25/MIT-6.S081-lab02/</id>
    <published>2024-02-25T03:30:22.000Z</published>
    <updated>2024-09-03T02:19:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前置准备">前置准备</h2><p>主要内容为自己实现系统调用，或者优化已有的系统调用。</p><p>根据<ahref="https://pdos.csail.mit.edu/6.828/2021/schedule.html">课程官网</a>的要求，需要阅读完教材的第二章<spanclass="math inline">\(Operating \space system \spaceorganization\)</span>。并且读懂下列源代码：<code>kernel/proc.h</code>,<code>kernel/defs.h</code>, <code>kernel/entry.S</code>,<code>kernel/main.c</code>, <code>user/initcode.S</code>,<code>user/init.c</code>, 简略了解<code>kernel/proc.c</code>,<code>kernel/exec.c</code>。</p><p>相关笔记参考: <ahref="https://gejxd.github.io/2024/02/25/MIT-6.S081-lab02%20Notes/">lecture2 Notes</a></p><p>将<code>util</code>分支所有内容都上传仓库后，执行下列命令来切换分支<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git fetch<br>git checkout syscall<br>make clean<br></code></pre></td></tr></table></figure></p><p>此外，新建一个<code>syscall_dev</code>分支来进行实际实验。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout -b syscall_dev<br></code></pre></td></tr></table></figure><p>在<code>syscall_dev</code>中每通过一个作业的测试，提交（gitcommit）你的代码，并将所做的修改合并（git merge）到util中，然后提交（gitpush）到github。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add .<br>git commit -m <span class="hljs-string">&quot;xxxxxxxx&quot;</span><br>git checkout syscall<br>git merge syscall_dev<br>git push github syscall:syscall<br></code></pre></td></tr></table></figure><h2 id="system-call-tracing-moderate">System call tracing(moderate)</h2><h3 id="statement">Statement</h3><blockquote><p>在本作业中，你将添加一项系统调用跟踪功能，这可能会在以后的实验调试中有所帮助。你将创建一个新的跟踪系统调用来控制跟踪。它应该接受一个参数，即一个"掩码",该掩码的位数指定了要跟踪的系统调用。例如，要跟踪 fork系统调用，程序会调用 <code>trace(1&lt;&lt;SYS_fork)</code>，其中SYS_fork 是 kernel/syscall.h 中的系统调用编号。你必须修改 xv6内核，以便在每个系统调用即将返回时，如果掩码中设置了系统调用编号，就打印出一行。该行应包含进程ID、系统调用名称和返回值；无需打印系统调用参数。跟踪系统调用应启用对调用该调用的进程及其随后分叉的子进程的跟踪，但不应影响其他进程。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ trace 32 grep hello README<br>3: syscall <span class="hljs-built_in">read</span> -&gt; 1023<br>3: syscall <span class="hljs-built_in">read</span> -&gt; 966<br>3: syscall <span class="hljs-built_in">read</span> -&gt; 70<br>3: syscall <span class="hljs-built_in">read</span> -&gt; 0<br>$<br>$ trace 2147483647 grep hello README<br>4: syscall trace -&gt; 0<br>4: syscall <span class="hljs-built_in">exec</span> -&gt; 3<br>$<br>$ grep hello README<br>$<br>$ trace 2 usertests forkforkfork<br>usertests starting<br><span class="hljs-built_in">test</span> forkforkfork: 407: syscall fork -&gt; 408<br>408: syscall fork -&gt; 409<br>409: syscall fork -&gt; 410<br>410: syscall fork -&gt; 411<br>409: syscall fork -&gt; 412<br>410: syscall fork -&gt; 413<br>409: syscall fork -&gt; 414<br>411: syscall fork -&gt; 415<br>...<br>$   <br></code></pre></td></tr></table></figure><p>在第一个样例中，<code>trace</code> 只在 <code>grep</code> 中追踪<code>read</code> 系统调用。<span class="math inline">\(32\)</span> 是<span class="math inline">\(1 &lt;&lt; sys_read\)</span> 的结果。在第二个样例中，<code>trace</code>追踪所有在<code>grep</code>中的系统调用，<spanclass="math inline">\(2147483647\)</span> 是 <spanclass="math inline">\(31\)</span> 位二进制位都置1。 在第三个样例中，进程并没有进行追踪。 在第四个样例中，<code>trace</code>最终所有后续的<code>fork</code>系统调用。</p><p>如果程序正确，应该得到一致的输出(进程号可能有所出入，但其他都应该一致)。</p><h3 id="hints">Hints</h3><ul><li>在 <code>Makefile</code> 中的<code>UPROGS</code> 添加<code>$U/_trace</code>。</li><li>运行 <code>make qemu</code>，你会发现编译器无法编译<code>user/trace.c</code>，因为系统调用的用户空间存根还不存在：在<code>user/user.h</code> 中添加一个系统调用原型，在<code>user/usys.pl</code> 中添加一个存根，在<code>kernel/syscall.h</code> 中添加一个系统调用号。<code>Makefile</code> 会调用 perl 脚本 <code>user/usys.pl</code>，生成<code>user/usys.S</code>，即实际的系统调用存根，它使用 RISC-V ecall指令过渡到内核。解决编译问题后，运行<code>trace 32 grep hello README</code>；由于尚未在内核中实现系统调用，所以会失败），将父进程的跟踪掩码复制到子进程。</li><li>在 <code>kernel/sysproc.c</code> 中添加一个<code>sys_trace()</code>函数，通过在 proc 结构（参见<code>kernel/proc.h</code>）中的一个新变量中记住参数来实现新的系统调用。从用户空间获取系统调用参数的函数在<code>kernel/syscall.c</code> 中，你可以在 <code>kernel/sysproc.c</code>中看到使用这些函数的示例。</li><li>修改 <code>fork()</code>（参见<code>kernel/proc.c</code>），将父进程的跟踪掩码复制到子进程。</li><li>修改 <code>kernel/syscall.c</code> 中的 <code>syscall()</code>函数，以打印跟踪输出。您需要添加一个系统调用名称数组作为索引。</li></ul><h3 id="analysis-solution">Analysis &amp; Solution</h3><p>前文末尾(<ahref="https://gejxd.github.io/2024/02/25/MIT-6.S081-lab02%20Notes/#starting-the-first-process">传送门</a>)已经说过了xv6 进行系统调用的过程，这里就略过了。</p><p>提示<span class="math inline">\(1\)</span>和提示<spanclass="math inline">\(2\)</span>没什么好说的。直接看<code>kernel/sysproc.c</code>文件。可以看到其他系统调用是怎么实现的。下面以<code>exit</code>来分析。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C">uint64 <span class="hljs-title function_">sys_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">if</span> (argint(<span class="hljs-number">0</span>, &amp;n) &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-built_in">exit</span>(n);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   <span class="hljs-comment">// not reached</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，首先从<code>trapfram-&gt;a0</code>寄存器拿出第一个参数(由<code>argint()</code>完成)。然后把更多实现细节放到了<code>exit</code>函数中来实现。可以看出，系统调用基本遵循这个流程：在<code>sys_xxxx</code>中处理参数、互斥锁等失误。如果还有复杂的功能，则放到具体<code>xxxx</code>函数里面实现。</p><p>我们的<code>sys_trace</code>只需要将<code>p-&gt;trace_mask</code>置为<code>p-&gt;trapframe-&gt;a0</code>的值即可。所以有：在<code>kernel/sysproc.c</code>中添加下面代码：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">sys_trace</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-type">int</span> mask;<br>    <span class="hljs-keyword">if</span> (argint(<span class="hljs-number">0</span>, &amp;mask) &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <br>    myproc()-&gt;trace_mask = mask;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>然后打开<code>kernel/syscall.c</code>，找到<code>syscall()</code>这个函数。所有系统调用都是通过<code>syscall</code>函数来调用的。根据提示，我们只需要将<code>p-&gt;trace_mask</code>拿出来，然后看系统调用号这一位是否为<spanclass="math inline">\(1\)</span>，如果为<spanclass="math inline">\(1\)</span>，则输出信息即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">char</span>* syscall_name[] = <br>    &#123;<span class="hljs-string">&quot;#&quot;</span>,   <span class="hljs-comment">// to make index start from 1;</span><br>    <span class="hljs-string">&quot;fork&quot;</span>,  <span class="hljs-string">&quot;exit&quot;</span>,   <span class="hljs-string">&quot;wait&quot;</span>,  <span class="hljs-string">&quot;pipe&quot;</span>,  <span class="hljs-string">&quot;read&quot;</span>,   <span class="hljs-string">&quot;kill&quot;</span>,<br>    <span class="hljs-string">&quot;exec&quot;</span>,  <span class="hljs-string">&quot;fstat&quot;</span>,  <span class="hljs-string">&quot;chdir&quot;</span>, <span class="hljs-string">&quot;dup&quot;</span>,   <span class="hljs-string">&quot;getpid&quot;</span>, <span class="hljs-string">&quot;sbrk&quot;</span>,<br>    <span class="hljs-string">&quot;sleep&quot;</span>, <span class="hljs-string">&quot;uptime&quot;</span>, <span class="hljs-string">&quot;open&quot;</span>,  <span class="hljs-string">&quot;write&quot;</span>, <span class="hljs-string">&quot;mknod&quot;</span>,  <span class="hljs-string">&quot;unlink&quot;</span>,<br>    <span class="hljs-string">&quot;link&quot;</span>,  <span class="hljs-string">&quot;mkdir&quot;</span>,  <span class="hljs-string">&quot;close&quot;</span>, <span class="hljs-string">&quot;trace&quot;</span>&#125;;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">syscall</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-type">int</span> num;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span>* <span class="hljs-title">p</span> =</span> myproc();<br><br>    num = p-&gt;trapframe-&gt;a7;<br><br>    <span class="hljs-keyword">if</span> (num &gt; <span class="hljs-number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;<br>        p-&gt;trapframe-&gt;a0 = syscal## Submit lab<br><br>新建`time.txt`文件，输入一个整数表明完成所有实验的耗时。<br><br>运行`make grade`, 得分为<span class="hljs-number">100</span>。<br>![](/img/<span class="hljs-number">6.</span>S081/Lab<span class="hljs-number">-01</span>/grade.png)<br><br>运行`make handin`, 根据提示将`API KEY`填入。s -&gt; %d\n<span class="hljs-string">&quot;, p-&gt;pid, syscall_name[num], p-&gt;trapframe-&gt;a0);</span><br><span class="hljs-string">        &#125;</span><br><span class="hljs-string">    &#125; else &#123;</span><br><span class="hljs-string"></span><br><span class="hljs-string">为了子进程也能继续追踪，我们看一眼`fork`函数。可以看到，`fork`函数其实就是新创建了一个`struct proc* np`，然后把父进程的所有东西都复制给子进程。同理，我们把`trace_mask`也复制给子进程即可。</span><br><span class="hljs-string"></span><br><span class="hljs-string">```C</span><br><span class="hljs-string">// 在合适位置添加</span><br><span class="hljs-string">np-&gt;trace_mask = p-&gt;trace_mask;</span><br></code></pre></td></tr></table></figure><p>运行结果: <img src="/img/6.S081/Lab-02/run_trace.png" /> <imgsrc="/img/6.S081/Lab-02/test_trace.png" /></p><h2 id="sysinfo-moderate">sysinfo (moderate)</h2><h3 id="statement-1">Statement</h3><blockquote><p>在本作业中，你将添加一个系统调用<code>sysinfo</code>，用于收集运行系统的信息。系统调用需要一个参数：指向<code>struct sysinfo</code> 的指针（参见<code>kernel/sysinfo.h</code>）。内核应填写该结构体的字段：<code>freemem</code>字段应设置为可用内存的字节数## Submit lab</p></blockquote><p>新建<code>time.txt</code>文件，输入一个整数表明完成所有实验的耗时。</p><p>运行<code>make grade</code>, 得分为100。 <imgsrc="/img/6.S081/Lab-01/grade.png" /></p><p>运行<code>make handin</code>,根据提示将<code>API KEY</code>填入。，<code>nproc</code>字段应设置为状态不是 <code>UNUSED</code>的进程数。我们提供了一个测试程序 <code>sysinfotest</code>；如果打印出<code>sysinfotest： OK</code>，则视为通过。</p><h3 id="hints-1">Hints</h3><ul><li>在 Makefile 的 UPROGS 中添加 $U/_sysinfotest。</li><li>运行 <code>make qemu</code>。将提示 <code>user/sysinfotest.c</code>无法编译。添加系统调 <code>sysinfo</code>，步骤与前面的作业相同。在<code>user/user.h</code> 中声明 <code>sysinfo()</code> 的原型，需##Submit lab</li></ul><p>新建<code>time.txt</code>文件，输入一个整数表明完成所有实验的耗时。</p><p>运行<code>make grade</code>, 得分为100。 <imgsrc="/img/6.S081/Lab-01/grade.png" /></p><p>运行<code>make handin</code>, 根据提示将<code>API KEY</code>填入。解决编译问题后，运行<code>sysinfotest</code>；由于内核中尚未实现系统调用，所以会失败。 -<code>sysinfo</code> 需要将 <code>struct sysinfo</code>复制到用户空间；有关如何使用 <code>copyout()</code>进行复制的示例，请参见 <code>sys_fstat()(kernel/sysfile.c)</code> 和<code>filestat()(kernel/file.c)</code> - 要收集可用内存量，请在<code>kernel/kalloc.c</code> 中添加一个函数。 - 要收集进程数，请在<code>kernel/proc.c</code> 中添加一个函数。</p><h3 id="analysis-solution-1">Analysis &amp; Solution</h3><p>先按照上一个任务的方法加入一个 <code>sysinfo</code> 系统调用. 这里在kernel 文件夹下再写一个 <code>sysinfo.c</code> 来实现这个系统调用. 在<code>Makefile</code> 的 <code>OBJS</code> 加入<code>$K/sysinfo.o \</code>(因为我在sysinfo.c中实现，所以要链接这个文件。如果直接在<code>kernel/proc.c</code>中实现就不用).</p><p>看<code>filestat()</code>函数能得知<code>copyout</code>函数的功能，加上<code>sys_fstat()</code>中虚拟地址是从<code>a0</code>读出来的。所以很容易能写出下面代码。</p><p><code>sysinfo.c</code>： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;riscv.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;defs.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;date.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;param.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;memlayout.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;spinlock.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;proc.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;sysinfo.h&quot;</span></span><br><br><span class="hljs-keyword">extern</span> uint64 <span class="hljs-title function_">freemem</span><span class="hljs-params">()</span>;<br><span class="hljs-keyword">extern</span> uint32 <span class="hljs-title function_">num_proc</span><span class="hljs-params">()</span>;<br><br>uint64 <span class="hljs-title function_">sys_sysinfo</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sysinfo</span> <span class="hljs-title">info</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span>* <span class="hljs-title">p</span> =</span> myproc();<br><br>    uint64 addr;<br>    <span class="hljs-keyword">if</span> (argaddr(<span class="hljs-number">0</span>, &amp;addr) &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>    info.freemem = freemem();<br>    info.nproc = num_proc();<br><br>    <span class="hljs-keyword">if</span> (copyout(p-&gt;pagetable, addr, (<span class="hljs-type">char</span>*)&amp;info, <span class="hljs-keyword">sizeof</span>(info)) &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>然后是<code>freemem()</code>和<code>num_proc()</code>。</p><p>在<code>kernel/kalloc.c</code>中添加，看一下前面的<code>kalloc()</code>函数，在看一下<code>struct kmem</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span>* <span class="hljs-title">next</span>;</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">lock</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span>* <span class="hljs-title">freelist</span>;</span><br>&#125; kmem;<br><br><span class="hljs-comment">// Allocate one 4096-byte page of physical memory.</span><br><span class="hljs-comment">// Returns a pointer that the kernel can use.</span><br><span class="hljs-comment">// Returns 0 if the memory cannot be allocated.</span><br><span class="hljs-type">void</span>* <span class="hljs-title function_">kalloc</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span>* <span class="hljs-title">r</span>;</span><br><br>    acquire(&amp;kmem.lock);<br>    r = kmem.freelist;<br>    <span class="hljs-keyword">if</span> (r) kmem.freelist = r-&gt;next;<br>    release(&amp;kmem.lock);<br><br>    <span class="hljs-keyword">if</span> (r) <span class="hljs-built_in">memset</span>((<span class="hljs-type">char</span>*)r, <span class="hljs-number">5</span>, PGSIZE);   <span class="hljs-comment">// fill with junk</span><br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">void</span>*)r;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中<code>freelisk</code>是一个链表，存储所有空闲内存页面的地址。所以我们只需要遍历这个链表，每一项都加上<code>PGSIZE</code>即可。</p><p>freemem： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C">uint64 <span class="hljs-title function_">freemem</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span>* <span class="hljs-title">r</span>;</span><br>    acquire(&amp;kmem.lock);<br>    r = kmem.freelist;<br><br>    uint64 tot = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (;r;r = r-&gt;next) tot += PGSIZE;<br><br>    release(&amp;kmem.lock);<br><br>    <span class="hljs-keyword">return</span> tot;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>然后翻<code>kernel/proc.c</code>中的<code>procdump</code>函数可以知道，<code>proc</code>数组中存放的是所有进程控制块的地址，所以遍历<code>proc</code>即可。</p><p>在<code>kernel/proc.c</code>中添加： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C">uint32 <span class="hljs-title function_">num_proc</span><span class="hljs-params">()</span> &#123;<br>    uint32 tot = <span class="hljs-number">0</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span>* <span class="hljs-title">p</span>;</span><br>    <span class="hljs-keyword">for</span> (p = proc;p &lt; &amp;proc[NPROC];p ++) &#123;<br>        <span class="hljs-keyword">if</span> (p-&gt;state != UNUSED) tot ++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> tot;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>运行结果： <img src="/img/6.S081/Lab-02/run_sysinfo.png" /></p><h2 id="submit-lab">Submit lab</h2><p>新建<code>time.txt</code>文件，输入一个整数表明完成所有实验的耗时。</p><p>运行<code>make grade</code>, 得分为100。 <imgsrc="/img/6.S081/Lab-02/grade.png" /></p><p>运行<code>make handin</code>,根据提示将<code>API KEY</code>填入。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前置准备&quot;&gt;前置准备&lt;/h2&gt;
&lt;p&gt;主要内容为自己实现系统调用，或者优化已有的系统调用。&lt;/p&gt;
&lt;p&gt;根据&lt;a
href=&quot;https://pdos.csail.mit.edu/6.828/2021/schedule.html&quot;&gt;课程官网&lt;/a&gt;的要求，需要阅</summary>
      
    
    
    
    <category term="6.S081" scheme="https://acmicpc.top/categories/6-S081/"/>
    
    
    <category term="6.S081" scheme="https://acmicpc.top/tags/6-S081/"/>
    
  </entry>
  
  <entry>
    <title>MIT 6.S081 第二章笔记 | 操作系统结构</title>
    <link href="https://acmicpc.top/2024/02/25/MIT-6.S081-lab02%20Notes/"/>
    <id>https://acmicpc.top/2024/02/25/MIT-6.S081-lab02%20Notes/</id>
    <published>2024-02-25T02:40:24.000Z</published>
    <updated>2024-08-22T09:34:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>操作系统应该实现三个功能：<strong>并发</strong>、<strong>隔离</strong>、<strong>交互</strong>。即能保证多个程序都能分到硬件资源；各个进程之间的内存、指令、数据相互隔离，一个进程崩溃不会影响到其他进程；进程之间能通过受控的接口来进行通信。</p><p>操作系统提供了高级别的抽象，来管理硬件资源。例如，用<strong>文件描述符</strong>来抽象磁盘、内存、管道等资源，用户程序能通过简单的<code>read</code>、<code>write</code>、<code>close</code>来访问所有存储资源，而不用关心是和磁盘、内存、管道、还是标准输入输出交互。</p><h2 id="user-mode-supervisor-mode-machine-mode">2.2 User mode、supervisor mode、 machine mode</h2><p>为了实现进程隔离，<span class="math inline">\(RISC-V\)</span>CPU在硬件上提供3种执行命令的模式：machine mode, supervisor mode, usermode。</p><ol type="1"><li><p><span class="math inline">\(machine \space mode\)</span>：机器模式拥有全权限。CPU以机器模式启动。机器模式大多时候用于配置计算机。xv6执行必要的几行指令后就转为监管模式。</p></li><li><p><span class="math inline">\(supervisor \space mode\)</span>：在监管模式下，CPU可以执行特权指令(<span class="math inline">\(privileged\space instructions\)</span>),比如中断管理、对存储页表的寄存器进行读写操作、执行系统调用。运行在<em>监管模式</em>也称为运行在<em>内核空间</em>(<spanclass="math inline">\(kernel \spacespace\)</span>)。运行在内核空间的程序被称作<em>内核</em>。</p></li><li><p><span class="math inline">\(user \space mode\)</span>：用户模式只能执行用户指令，例如<code>add</code>、<code>jump</code>等简单无害的指令。运行在<em>用户模式</em>也称为运行在<em>用户空间</em>。</p></li></ol><p>运行在用户空间的程序如果执行了特权指令，CPU会转换到特权模式并将该程序强制停止。</p><h2 id="the-kernel-organization">2.3 The kernel organization</h2><p><em>monolithic kernel</em>： 整个操作系统在kernel中，所有systemcall都在supervisor mode下运行。xv6是一个monolithic kernel。</p><p><em>micro kernel</em>： 将必须运行在supervisormode下的操作系统代码压到最小，保证kernel的安全性和简洁，将大部分的操作系统代码执行在usermode下。</p><p>宏内核易于设计，但是系统调用较复杂，并且一旦任意一条特权指令出错，整个操作系统都会崩溃。</p><p>如下图所示，文件系统作为用户级别的进程执行，用户通过进程间通信请求文件系统的服务。这种运行在用户模式的内核模块称作<code>server</code>。微内核更轻便、稳定，但是难于设计和实现。</p><figure><img src="/img/6.S081/Lab-02/micro_kernel.png"alt="Figure： 1.1 A microkernel with a file-system server" /><figcaption aria-hidden="true">Figure： 1.1 A microkernel with afile-system server</figcaption></figure><p>下图列出了 xv6的所有内核文件和其对应的功能。模块间接口定义在<code>kernel/defs.h</code>文件中。<img src="/img/6.S081/Lab-02/kernel_src.png"alt="xv6&#39;s kernel source file" /></p><h2 id="process-overview">2.4 Process overview</h2><p>隔离的单元叫作<strong>进程</strong>,一个进程不能破坏或监听另一个进程的内存、CPU、文件描述符，也不能破坏kernel 本身。</p><p>为了加强隔离，内核为每个进程提供了一块私有、独立的内存，称作地址空间(addressspace)，这让进程认为自己拥有一个独立的机器，而不用和其他进程共享硬件资源。其他的进程不能访问这块内存。</p><p>操作系统使用<strong>页表(pagetable)</strong>的概念来实现内存独立。页表提供<strong>虚拟地址</strong>(RISC-V操作的地址)到<strong>物理地址</strong>(CPU芯片发送到内存的地址)的映射(或转换)。</p><p>xv6 为每一个进程维护一个独立的页表，如下图所示。地址空间从 <spanclass="math inline">\(0\)</span>号地址开始，首先是指令，然后是全局变量(<strong>栈空间</strong>)，之后是进程可以根据需要灵活拓展的<strong>堆空间</strong>(用于<code>malloc</code>)。</p><p>题外话：操作系统中的堆栈和数据结构中的堆栈没有关系。<strong>堆</strong>是指在运行时动态分配的空间，<strong>栈</strong>是在运行前确定的静态空间。</p><figure><img src="/img/6.S081/Lab-02/page_table.png"alt="Figure： 1.2 Layout of a process’s virtual address space" /><figcaption aria-hidden="true">Figure： 1.2 Layout of a process’svirtual address space</figcaption></figure><p>RISC-V使用 <span class="math inline">\(64\)</span> 位指针，但是 xv6只使用低 <span class="math inline">\(38\)</span>位就够了，因此最大地址是 <span class="math inline">\(2^{38} - 1 =0x3fffffffff = MAXVA\)</span>。</p><p>xv6使用<code>struct proc</code>(声明在<code>kernel/proc.h</code>)来维护每个进程的状态。进程最重要的几个信息:1. 页表(<code>p-&gt;pagetable</code>). 2.进程栈(<code>p-&gt;kstack</code>). 3.进程运行状态(<code>p-&gt;state</code>)。</p><p>每个进程中都有线程(<spanclass="math inline">\(thread\)</span>)，是执行进程命令的最小单元，可以被暂停和继续。</p><p>每个进程有两个栈：用户栈(user stack)和内核栈(kernelstack)。当进程在userspace中进行时只使用用户堆栈，当进程进入了内核(比如进行了systemcall)使用内核堆栈。</p><p>操作系统给进程提供了两种假象:地址空间给进程提供了独自拥有内存的假象、线程给进程提供了独自拥有 CPU的假象。</p><h2 id="starting-the-first-process">2.5 Starting the first process</h2><p>当RISC-V芯片通电后，它会自动读取 <spanclass="math inline">\(ROM\)</span> 的指令初始化自己，并运行引导程序(在xv6 中为<code>kernel/kernel.ld</code>)将内核加载入内存中。然后在machinemode从_entry(<code>kernel/entry.S</code>)开始运行xv6。bootloader将xv6kernel加载到0x80000000的物理地址中，因为前面的地址中有I/O设备。</p><p><code>start</code>函数中，先以machinemode做了一些配置，然后调用<code>mret</code>指令跳转到supervisor mode,并通过修改 PC 寄存器的值跳转到<code>kernel/main.c</code>。</p><p><code>main</code>先对一些设备和子系统进行初始化，然source/_posts/2024/MIT-6.S081-lab03.md进程将要请求的系统调用号写入<code>p-&gt;trapframe-&gt;a7</code>,其中<code>p</code>为当前进程的<code>struct proc</code>。并且将参数写入<code>p-&gt;trapframe-&gt;a0</code>和其他寄存器。之后进程执行<code>ecall</code>指令，并保存进程相关信息(其中就包括<code>trapframe</code>)。然后开始执行<code>syscall(kernel/syscall.c:95)</code></p><p><code>syscall()</code>从<code>trapframe-&gt;a7</code>中拿到索引，通过一个函数指针数组<code>syscall[]</code>(定义在<code>kernel/syscall.c</code>中)获取对应系统调用的函数指令。然后将系统调用的返回写入<code>p-&gt;trapframe-&gt;a0</code>。</p><p>系统调用号( <span class="math inline">\(system \space call \spacenumber\)</span>)定义在<code>kernel/syscall.h</code>中，作为内核找到函数指针的索引。</p><h2 id="system-call-arguments">2.7 System call arguments</h2><p>对应教材第4章第4节。</p><p><code>trap</code>相关的代码将用户寄存器保存在当前进程的<code>trapframe</code>中，内核函数<code>argint</code>、<code>argaddr</code>、<code>argfd</code>从<code>trapframe</code>中的指定寄存器得到数据，并分别按照整数、地址、文件描述符解析。通过<code>argrow</code>能方便的读取第<spanclass="math inline">\(n\)</span>个寄存器的内容(这些函数都定义在<code>kernel\syscall.c</code>中)。</p><p>大部分参数都通过指针来传递，有时用户程序还会请求内核访问特定内存并写入数据。为了防止用户程序传入恶意参数，内核使用<code>fetchstr</code>和<code>copyinstr</code>来实现安全地与用户提供的地址之间传输数据的功能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;操作系统应该实现三个功能：&lt;strong&gt;并发&lt;/strong&gt;、&lt;strong&gt;隔离&lt;/strong&gt;、&lt;strong&gt;交互&lt;/strong&gt;。即能保证多个程序都能分到硬件资源；各个进程之间的内存、指令、数据相互隔离，一个进程崩溃不会影响到其他进程；进程之间能通过受控的接</summary>
      
    
    
    
    <category term="6.S081" scheme="https://acmicpc.top/categories/6-S081/"/>
    
    
    <category term="6.S081" scheme="https://acmicpc.top/tags/6-S081/"/>
    
  </entry>
  
  <entry>
    <title>MIT 6.S081 Lab1 util：Unix utilities | UNIX 实用程序</title>
    <link href="https://acmicpc.top/2024/02/25/MIT-6.S081-lab01/"/>
    <id>https://acmicpc.top/2024/02/25/MIT-6.S081-lab01/</id>
    <published>2024-02-24T19:07:25.000Z</published>
    <updated>2024-08-28T15:32:40.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前置准备">前置准备</h2><p>主要内容为如何使用已有的系统调用编写用户程序,例如<code>ls</code>、<code>xargs</code>、<code>find</code>等常用命令的实现。</p><p>根据课程官网的要求，需要看完<code>Lecture 1</code>,阅读完教材第一章<spanclass="math inline">\(Operation \space System \spaceinterfaces\)</span>。</p><p>此外，实验手册中的<code>Hints</code>很重要，大多数实验跟着提示一步一步实现都能完成。</p><h2 id="sleep-easy">Sleep (easy)</h2><h3 id="statement">Statement</h3><blockquote><p>为xv6实现 <span class="math inline">\(UNIX\)</span>中的<code>sleep</code>程序。<code>sleep</code>程序应该暂定用户指定的<code>tick</code>数量。<code>tick</code>是xv6内核定义的时间概念，即定时器两次中断之间的间隔时间。你的<code>solution</code>应该存储在<code>user/sleep.c</code>文件下。</p></blockquote><h3 id="hints">Hints</h3><ul><li>在开始实现前，确保你阅读了<code>xv6 book</code>的第一章。</li><li>查看其他xv6中实现的其他用户程序(例如<code>user/echo.c</code>、<code>user/grep.c</code>、<code>user/rm.c</code>)，了解如何从终端传递参数到程序中。</li><li>如果用户忘记传递参数，<code>sleep</code>应该显示错误消息并中断。</li><li>终端参数作为字符串传递，你需要用<code>atoi</code>(在<code>user/ulib.c</code>中实现)将其转换为int类型。</li><li>使用<code>sleep</code>系统调用。</li><li>有关实现<code>sleep</code>系统调用（见sys_sleep）的 xv6内核代码，请参见<code>kernel/sysproc.c</code>。有关可从用户程序调用sleep系统调用的 C语言定义，请参见<code>user/user.h</code>；有关从用户代码跳转到内核中<code>sleep</code>的汇编代码，请参见<code>user/usys.S</code>。</li><li>确保<code>main</code>函数中使用<code>exit()</code>来退出程序。</li><li>将<code>sleep.c</code>添加到<code>Makefile</code>的<code>UPROGS</code> 中；完成后，在终端输入 <code>make qemu</code>来编译你的程序，你就可以在 xv6 shell 中运行它了。</li></ul><h3 id="analysis-solution">Analysis &amp; Solution</h3><p>首先按照Hint-1的提示看一眼<code>user/echo.c</code>是什么，可以看到下面的一段代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> &#123;<br>    <span class="hljs-type">int</span> i;<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; argc; i++) &#123;<br>        write(<span class="hljs-number">1</span>, argv[i], <span class="hljs-built_in">strlen</span>(argv[i]));<br>        <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &lt; argc) &#123;<br>            write(<span class="hljs-number">1</span>, <span class="hljs-string">&quot; &quot;</span>, <span class="hljs-number">1</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            write(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;\n&quot;</span>, <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>argc</code>存储终端传入的参数数量，<code>argv</code>存储传入的参数的具体内容。</p><p>于是可以写出下面的代码： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> &#123;<br>  <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;Usage: sleep &lt;ticks&gt;\n&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-type">int</span> time = atoi(argv[<span class="hljs-number">1</span>]);<br>  sleep(time);<br><br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure></p><p>然后在<code>Makefile</code>中的<code>UPROGS</code>添加一行<code>$U/_sleep\</code>，</p><p><img src="/img/6.S081/Lab-01/UPROGS.png" /></p><p>运行<code>qemu make</code>，编译完成后输入<code>sleep 10</code>,可以看到成功运行。 <img src="/img/6.S081/Lab-01/run_sleep.png" /></p><p>运行<code>./grade-lab-util sleep</code>测试一下。 <imgsrc="/img/6.S081/Lab-01/test_sleep.png" /></p><h2 id="pingpong-easy">PingPong (easy)</h2><h3 id="statement-1">Statement</h3><blockquote><p>编写一个程序，使用 UNIX 系统调用在两个进程之间通过一对管道"ping-pong" 传送一个字节，每个方向发送一次。父进程应向子进程发送一个字节，子进程应打印<code>&lt;pid&gt;: received ping</code>（<code>&lt;pid&gt;</code>是其进程ID），并将一个字节写入父进程的管道，然后退出；父进程应从子进程读取该字节，打印<code>&lt;pid&gt;: received pong</code>，然后退出。您的解决方案应放在user/pingpong.c 文件中。</p></blockquote><h3 id="hints-1">Hints</h3><ul><li>使用<code>pipe</code>创建管道</li><li>使用<code>fork</code>创建子进程</li><li>使用<code>read</code>来向管道中的读取端读取数据，<code>write</code>来向管道中的写入端写入数据。</li><li>使用<code>getpid</code>来获取当前进程的PID。</li><li>添加程序到<code>Makefile</code>里的<code>UPROGS</code></li><li>xv6的用户程序可以使用有限的库函数，列出在<code>user/user.h</code>中。源代码(包括其他的系统调用)在<code>user/ulib.c</code>、<code>user/printf.c</code>、<code>user/umalloc.c</code>。</li></ul><h3 id="analysis-solution-1">Analysis &amp; Solution</h3><p>和书上<code>1.3</code>的例子差不多，用大小为2的数组创建管道，其中<code>p[0]</code>是读取端，<code>p[1]</code>是写入端，然后<code>fork</code>分别发送读取。</p><p><code>write</code>和<code>read</code>的第二个参数是一个地址，用char存储的话需要取地址，用char[]就没这么多事了。</p><p>需要注意的是，子进程和父进程的文件描述符是一样的，但并不是引用，在父进程关闭fd不会影响子进程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> &#123;<br>    <span class="hljs-type">int</span> p[<span class="hljs-number">2</span>];<br>    pipe(p);<br><br>    <span class="hljs-type">char</span> msg[<span class="hljs-number">2</span>] = <span class="hljs-string">&quot;@&quot;</span>;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">2</span>];<br><br>    <span class="hljs-keyword">if</span> (fork() != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (write(p[<span class="hljs-number">1</span>], msg, <span class="hljs-number">1</span>) != <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;cannot write a byte to child.\n&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>        close(p[<span class="hljs-number">1</span>]);<br><br>        <span class="hljs-keyword">if</span> (read(p[<span class="hljs-number">0</span>], buf, <span class="hljs-keyword">sizeof</span>(buf))<br>        close(p[<span class="hljs-number">0</span>]);<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;%d: received pong\n&quot;</span>, getpid());<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (read(p[<span class="hljs-number">0</span>], buf, <span class="hljs-keyword">sizeof</span>(buf)) != <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;cannot read a byte from parent.\n&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>        close(p[<span class="hljs-number">0</span>]);<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;%d: received ping\n&quot;</span>, getpid());<br><br>        <span class="hljs-keyword">if</span> (write(p[<span class="hljs-number">1</span>], msg, <span class="hljs-number">1</span>) != <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;cannot write a byte to parent.\n&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>        close(p[<span class="hljs-number">1</span>]);<br>    &#125;<br>e<br></code></pre></td></tr></table></figure><p>运行结果： <img src="/img/6.S081/Lab-01/run_pingpong.png" /> <imgsrc="/img/6.S081/Lab-01/test_pingpong.png" /></p><h2 id="primes-moderate-hard">Primes (moderate / hard)</h2><h3 id="statement-2">Statement</h3><blockquote><p>通过<code>pipe</code>和<code>fork</code>编写一个并发版本的素数筛。这个想法来自与<spanclass="math inline">\(Doug \spaceMcllroy\)</span>，Unix管道的发明人。本页<ahref="https://swtch.com/~rsc/thread/">下半部分</a>的图片和周围的文字说明了如何操作。你的解决方案应该存放在<code>user/primes.c</code>文件下。</p></blockquote><p>第一个进程将<span class="math inline">\(2\)</span>到<spanclass="math inline">\(35\)</span>输入管道。对于每个质数，你都需要创建一个进程，该进程从左边的邻居管道中读取数据，并通过另一个管道向右边的邻居写入数据。由于xv6的文件描述符是有限的，我们只需要筛出35以内的质数。</p><h3 id="hints-2">Hints</h3><ul><li>及时关闭进程不需要的文件描述符，不然程序会用完有限的文件描述符。</li><li>一旦第一个进程发送了35，它应该直到所有的管道都关闭才退出，包括所有子进程、孙进程等。</li><li>提示： 当写入端的管道被关闭时，<code>read</code>返回<spanclass="math inline">\(0\)</span>。</li><li>最简单的方式是直接向管道写入32位的<code>int</code>数据，而不是用<code>ASCII</code>码来处理。</li><li>确保只在需要创建管道的时候创建管道。</li><li>添加程序到<code>UPROGS</code>。</li></ul><h3 id="analysis-solution-2">Analysis &amp; Solution</h3><p>其实就是通过管道来实现<ahref="https://zh.wikipedia.org/wiki/%E5%9F%83%E6%8B%89%E6%89%98%E6%96%AF%E7%89%B9%E5%B0%BC%E7%AD%9B%E6%B3%95">埃氏筛</a>(wiki打不开<ahref="https://baike.baidu.com/item/%E5%9F%83%E6%8B%89%E6%89%98%E6%96%AF%E7%89%B9%E5%B0%BC%E7%AD%9B%E6%B3%95/374984">点这个</a>)。</p><p>简单解释一下。第一个进程传入<span class="math inline">\(2 \rightarrow35\)</span>给第二个进程，第二个进程输出<spanclass="math inline">\(2\)</span>, 之后把所有没有因子<spanclass="math inline">\(2\)</span>的数都传递给下一个进程。同样，第三个进程输出<spanclass="math inline">\(3\)</span>，然后将所有没有因子<spanclass="math inline">\(3\)</span>的数都传给第<spanclass="math inline">\(4\)</span>个进程...。当管道中没有数的时候，说明所有质数都被筛出来了。整个过程就是参考资料中给的这张图。</p><p><img src="/img/6.S081/Lab-01/seive.png" /></p><p>很显然这是一个递归，还是一个线性的递归，读入完关闭管道就可以了。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">primes</span><span class="hljs-params">(<span class="hljs-type">int</span> left[<span class="hljs-number">2</span>], <span class="hljs-type">int</span> base)</span> &#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;prime %d\n&quot;</span>, base);<br><br>    <span class="hljs-type">int</span> right[<span class="hljs-number">2</span>];<br>    pipe(right);<br><br>    <span class="hljs-comment">// 将剔除后的数写入缓冲区</span><br>    <span class="hljs-type">int</span> cur, first = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span> (read(left[<span class="hljs-number">0</span>], &amp;cur, <span class="hljs-keyword">sizeof</span>(cur)) == <span class="hljs-keyword">sizeof</span>(cur)) &#123;<br>        <span class="hljs-keyword">if</span> (cur % base == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span> (first == <span class="hljs-number">-1</span>) first = cur;<br>        <span class="hljs-keyword">if</span> (write(right[<span class="hljs-number">1</span>], &amp;cur, <span class="hljs-keyword">sizeof</span>(cur)) != <span class="hljs-keyword">sizeof</span>(cur)) &#123;<br>            <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;pid %d: cannot wirite %d bytes to right.\n&quot;</span>, getpid(), <span class="hljs-keyword">sizeof</span>(cur));<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    close(left[<span class="hljs-number">0</span>]);<br><br>    <span class="hljs-keyword">if</span> (first == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (fork() != <span class="hljs-number">0</span>) &#123;<br>        close(right[<span class="hljs-number">1</span>]);<br>        close(right[<span class="hljs-number">0</span>]);<br>        <span class="hljs-comment">// 第i个子进程等待第i+1个子进程结束</span><br>        wait((<span class="hljs-type">int</span>*)<span class="hljs-number">0</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        close(right[<span class="hljs-number">1</span>]);<br>        primes(right, first);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> &#123;<br>    <span class="hljs-type">int</span> p[<span class="hljs-number">2</span>];<br>    pipe(p);<br><br>    <span class="hljs-comment">// 主进程 所有数都写入管道</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= <span class="hljs-number">35</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (write(p[<span class="hljs-number">1</span>], &amp;i, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)) != <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)) &#123;<br>            <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;cannot write %d bytes.\n&quot;</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (fork() != <span class="hljs-number">0</span>) &#123;<br>        close(p[<span class="hljs-number">1</span>]);<br>        close(p[<span class="hljs-number">0</span>]);<br>        <span class="hljs-comment">// 主进程等待第一个子进程结束</span><br>        wait((<span class="hljs-type">int</span>*)<span class="hljs-number">0</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        close(p[<span class="hljs-number">1</span>]);<br>        primes(p, <span class="hljs-number">2</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure></p><p>运行结果： <img src="/img/6.S081/Lab-01/run_primes.png" /> <imgsrc="/img/6.S081/Lab-01/test_primes.png" /></p><h2 id="find-moderate">find (moderate)</h2><h3 id="statement-3">Statement</h3><blockquote><p>写一个简单版本的UNIXfind程序：在文件树中找到有特定文件名的文件。你的解决方案应该放在<code>user/find.c</code>下。</p></blockquote><h3 id="hints-3">Hints</h3><ul><li>查看<code>user/ls.c</code>学习如何读取目录。</li><li>通过递归来允许查找子目录。</li><li>不要递归进<code>'.'</code>和<code>'..'</code>中。</li><li>对文件系统的更改会在运行qemu是持续存在，要恢复感觉的文件系统，请运行<code>make clean</code>，然后再运行<code>make qemu</code>。</li><li>你将会用到C strings。请参阅 <span class="math inline">\(K \&amp;R\)</span>第5.5节。</li><li>注意不能像 Python 那样使用 <code>==</code> 比较字符串。请使用<code>strcmp()</code> 代替。</li><li>将程序添加到 Makefile 的 <code>UPROGS</code> 中。</li></ul><h3 id="analysis-solution-3">Analysis &amp; Solution</h3><p>提示中提到了<code>user/ls.c</code>文件，我们先看一下<code>ls</code>命令的源码。</p><p>一开始是一个<code>fmtname</code>的函数，传入一个字符串，然后限制字符串长度为<code>DIRSIZ</code>。</p><p>之后就是<code>ls</code>函数的主体。先看一下<code>dirent</code>和<code>stat</code>两个结构体是什么。</p><p>在<code>kernel/fs.h</code>的末尾有这么两段代码 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// Directory is a file containing a sequence of dirent structures.</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DIRSIZ 14</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dirent</span> &#123;</span><br>    ushort inum;<br>    <span class="hljs-type">char</span> name[DIRSIZ];<br>&#125;;<br></code></pre></td></tr></table></figure>注释中明确说了"目录是一个包括一系列<code>dirent</code>结构体的文件'"。并且<code>name</code>字段的大小是<code>DIRSIZ</code>，这也解释了为什么<code>fmtname</code>要限制字符串长度。</p><p>在<code>kernel/stat.h</code>中可以看到下面这段代码 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> T_DIR 1      <span class="hljs-comment">// Directory</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> T_FILE 2     <span class="hljs-comment">// File</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> T_DEVICE 3   <span class="hljs-comment">// Device</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> &#123;</span><br>    <span class="hljs-type">int</span> dev;       <span class="hljs-comment">// File system&#x27;s disk device</span><br>    uint ino;      <span class="hljs-comment">// Inode number</span><br>    <span class="hljs-type">short</span> type;    <span class="hljs-comment">// Type of file</span><br>    <span class="hljs-type">short</span> nlink;   <span class="hljs-comment">// Number of links to file</span><br>    uint64 size;   <span class="hljs-comment">// Size of file in bytes</span><br>&#125;;<br></code></pre></td></tr></table></figure>结合<code>user/ls.c</code>中两个<code>if</code>中的处理。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">if</span> ((fd = open(path, <span class="hljs-number">0</span>)) &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;ls: cannot open %s\n&quot;</span>, path);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (fstat(fd, &amp;st) &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;ls: cannot stat %s\n&quot;</span>, path);<br>        close(fd);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>至此文件系统就能看出个大概了。在XV6中，一切都是以文件的形式来存储的，无论是目录、文本、设备等等所有东西，都被内核视为文件，只不过按不同的格式读取，或者以<code>stat</code>等结构体来标明他是什么。</p><p>正因为一切都是文件，所以我们可以用<code>open</code>系统调用来打开任意对象(例如上面的<code>open(path， 0)</code>)，并返回一个文件描述符，通过这个文件描述符，我们可以按照不同的结构来读出对象里的内容(可以从<code>path</code>中读出<code>dirent</code>,即目录中的文件名、路径名)。</p><p>对于每个读出的<code>dirent</code>对象，可以用<code>fstat</code>系统调用来获取他的信息，存储在一个<code>stat</code>类型的结构体中。例如，<code>stat.type</code>中指定了当前<code>dirent</code>是文件、目录、还是设备。</p><p>于是这道题的思路就很清晰了，不停从用户指定的路径中读出<code>dirent</code>,如果当前<code>dirent</code>是文件，则判断<code>dirent.name</code>是否和要查找的文件相同。如果当前<code>dirent</code>是目录，则递归遍历这个子目录。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/fs.h&quot;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">char</span>* path, <span class="hljs-type">char</span>* filename)</span> &#123;<br>    <span class="hljs-type">int</span> fd;<br>    <span class="hljs-keyword">if</span> ((fd = open(path, <span class="hljs-number">0</span>)) &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;find: cannot open %s\n&quot;</span>, path);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">st</span>;</span><br>    <span class="hljs-keyword">if</span> (fstat(fd, &amp;st) &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;find: cannot stat %s\n&quot;</span>, path);<br>        close(fd);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (st.type != T_DIR) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;find: %s should be a dir, but found a file.\n&quot;</span>, path);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">512</span>];<br>    <br>    <span class="hljs-comment">// strlen(path) + 1 表示path的长度 + &#x27;\0&#x27;</span><br>    <span class="hljs-comment">// DIRSIZ 是文件名最大长度, 见kernel/fs.h 54行</span><br>    <span class="hljs-comment">// 最后还要在末位加上`/`，e.g. code/user -&gt; code/user/</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strlen</span>(path) + <span class="hljs-number">1</span> + DIRSIZ + <span class="hljs-number">1</span> &gt; <span class="hljs-keyword">sizeof</span> buf) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;find: path too long.\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">strcpy</span>(buf, path);<br>    <span class="hljs-type">char</span> *p = buf + <span class="hljs-built_in">strlen</span>(buf);<br>    *p ++ = <span class="hljs-string">&#x27;/&#x27;</span>;<br>    <span class="hljs-comment">// 运算优先级: *p ---&gt; p ++. 即p指向&#x27;/&#x27;的后一个位置</span><br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dirent</span> <span class="hljs-title">de</span>;</span><br>    <span class="hljs-keyword">while</span> (read(fd, &amp;de, <span class="hljs-keyword">sizeof</span>(de)) == <span class="hljs-keyword">sizeof</span>(de)) &#123;<br>        <span class="hljs-keyword">if</span> (de.inum == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-comment">// 将de.name复制到p后面,最大长度为DIRSIZ</span><br>        memmove(p, de.name, DIRSIZ);<br>        p[DIRSIZ] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (stat(buf, &amp;st) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;find: cannot stat %s\n&quot;</span>, buf);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">switch</span> (st.type) &#123;<br>        <span class="hljs-keyword">case</span> T_FILE:<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(de.name, filename) == <span class="hljs-number">0</span>) <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;%s\n&quot;</span>, buf);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> T_DIR:<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(de.name, <span class="hljs-string">&quot;.&quot;</span>) == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(de.name, <span class="hljs-string">&quot;..&quot;</span>) == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>            find(buf, filename);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> &#123;<br>    <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;Usage: find [path] &lt;filename&gt;\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (argc == <span class="hljs-number">2</span>) &#123;<br>        find(<span class="hljs-string">&quot;.&quot;</span>, argv[<span class="hljs-number">1</span>]);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        find(argv[<span class="hljs-number">1</span>], argv[<span class="hljs-number">2</span>]);<br>    &#125;<br><br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果： <img src="/img/6.S081/Lab-01/run_find.png" /> <imgsrc="/img/6.S081/Lab-01/test_find.png" /></p><h2 id="xargs-moderate">xargs (moderate)</h2><h3 id="statement-4">Statement</h3><blockquote><p>编写一个简单版本的 <code>UNIX xargs</code>程序：从标准输入中读取行，并为每一行运行一个命令，同时将该行作为参数提供给命令。你的解决方案应放在<code>user/xargs.c</code> 文件中。</p></blockquote><p>下面的示例说明了 <code>xarg</code> 的行为： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">echo</span> hello too | xargs <span class="hljs-built_in">echo</span> <span class="hljs-built_in">bye</span><br><span class="hljs-built_in">bye</span> hello too<br>$<br></code></pre></td></tr></table></figure></p><p>请注意，这里的命令是 “echo bye”，而附加参数是 “hello too”，因此命令是“echo bye hello too”，输出结果是 "bye hello too”</p><p>请注意，UNIX 上的 <code>xargs</code>会进行优化，一次向命令提供多个参数。我们不希望你进行这种优化。要使 UNIX上的 <code>xargs</code> 按我们希望的方式运行，请在运行时将 -n 选项设为1。例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;1\n2&quot;</span> | xargs -n 1 <span class="hljs-built_in">echo</span> line<br>line 1<br>line 2<br>$<br></code></pre></td></tr></table></figure><h3 id="hints-4">Hints</h3><ul><li>使用 fork 和 exec 在每一行输入中调用命令。在父进程中使用 wait等待子进程完成命 令。</li><li>要读取单行输入内容，每次读取一个字符(<code>read</code>)，直到出现换行符（''）。</li><li><code>kernel/param.h</code> 声明了 <code>MAXARG</code>，这在需要声明<code>argv</code> 数组时可能有用。</li><li>将程序添加到 Makefile 的 UPROGS 中。</li><li>对文件系统的更改会在运行 qemu时持续存在；要获得一个干净的文件系统，请运行<code>make clean</code>，然后再运行 <code>make qemu</code>。</li></ul><h3 id="analysis-solution-4">Analysis &amp; Solution</h3><p><code>xargs</code>的功能是给定一个命令，例如上面的<code>echo line</code>,然后从<strong>标准输入流</strong>中读出许多行，把每一行的输入作为参数附加到给定的命令中。</p><p>比如 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$  find . b | xargs <span class="hljs-built_in">echo</span> hello<br>hello ./b<br>hello ./a/b<br></code></pre></td></tr></table></figure>对每一行读入都<code>fork</code>然后<code>exec</code>，模拟这个过程就行(指针指晕了)。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/param.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">getline</span><span class="hljs-params">(<span class="hljs-type">char</span>* buf, <span class="hljs-type">const</span> <span class="hljs-type">int</span> max)</span> &#123;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (read(<span class="hljs-number">0</span>, buf, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>)) &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (++cnt &gt; max) &#123;<br>            <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;xargs: input lines are too long.\n&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (*buf++ == <span class="hljs-string">&#x27;\n&#x27;</span>) <span class="hljs-keyword">break</span>;<br>    &#125;<br>    *(buf - <span class="hljs-number">1</span>) = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">parse</span><span class="hljs-params">(<span class="hljs-type">char</span>** args, <span class="hljs-type">char</span>* buf, <span class="hljs-type">const</span> <span class="hljs-type">int</span> max)</span> &#123;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (*buf) &#123;<br>        <span class="hljs-keyword">if</span> (cnt &gt;= max) &#123;<br>            <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;xargs: args are too many.\n&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">while</span> (*buf &amp;&amp; *buf == <span class="hljs-string">&#x27; &#x27;</span>) buf ++;<br>        <span class="hljs-keyword">if</span> (*buf == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>        args[cnt ++] = buf;<br>        <span class="hljs-keyword">while</span> (*buf &amp;&amp; *buf != <span class="hljs-string">&#x27; &#x27;</span>) buf ++;<br>        <span class="hljs-keyword">if</span> (*buf) *buf++ = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> &#123;<br>    <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;Usage: xargs &lt;command&gt; [arguments]\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-type">char</span>* args[MAXARG] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; argc; i++) &#123;<br>        args[i - <span class="hljs-number">1</span>] = argv[i];<br>    &#125;<br><br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">512</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">while</span> (getline(buf, <span class="hljs-keyword">sizeof</span> buf)) &#123;<br>        parse(args + argc - <span class="hljs-number">1</span>, buf, MAXARG - argc + <span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> pid = fork();<br>        <span class="hljs-keyword">if</span> (pid &gt; <span class="hljs-number">0</span>) &#123;<br>            wait((<span class="hljs-type">int</span>*)<span class="hljs-number">0</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">char</span> cmd[<span class="hljs-number">128</span>];<br>            <span class="hljs-built_in">strcpy</span>(cmd, args[<span class="hljs-number">0</span>]);<br>            exec(cmd, args);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;xargs: fork error.\n&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure></p><p>运行结果： <img src="/img/6.S081/Lab-01/run_xargs.png" /> <imgsrc="/img/6.S081/Lab-01/test_xargs.png" /></p><h2 id="submit-lab">Submit lab</h2><p>新建<code>time.txt</code>文件，输入一个整数表明完成所有实验的耗时。</p><p>运行<code>make grade</code>, 得分为100。 <imgsrc="/img/6.S081/Lab-01/grade.png" /></p><p>运行<code>make handin</code>,根据提示将<code>API KEY</code>填入。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前置准备&quot;&gt;前置准备&lt;/h2&gt;
&lt;p&gt;主要内容为如何使用已有的系统调用编写用户程序,
例如&lt;code&gt;ls&lt;/code&gt;、&lt;code&gt;xargs&lt;/code&gt;、&lt;code&gt;find&lt;/code&gt;等常用命令的实现。&lt;/p&gt;
&lt;p&gt;根据课程官网的要求，需要看完&lt;cod</summary>
      
    
    
    
    <category term="6.S081" scheme="https://acmicpc.top/categories/6-S081/"/>
    
    
    <category term="6.S081" scheme="https://acmicpc.top/tags/6-S081/"/>
    
  </entry>
  
  <entry>
    <title>MIT 6.S081 lab0：配置xv6环境+vscode调试</title>
    <link href="https://acmicpc.top/2024/02/08/MIT-6.S081-lab0-%E9%85%8D%E7%8E%AF%E5%A2%83/"/>
    <id>https://acmicpc.top/2024/02/08/MIT-6.S081-lab0-%E9%85%8D%E7%8E%AF%E5%A2%83/</id>
    <published>2024-02-07T22:51:39.000Z</published>
    <updated>2024-08-11T16:06:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>系统为Archlinux物理机，环境如下：</p><p><img src="/img/6.S081/neofetch.png" /></p><p>使用的xv6版本为2021版，运行环境为vscode + clangd + gbd。</p><h2 id="安装依赖">安装依赖</h2><p>参考：https://pdos.csail.mit.edu/6.828/2021/tools.html</p><p><strong>首先安装转义riscv64的包：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> pacman -S riscv64-linux-gnu-binutils riscv64-linux-gnu-gcc riscv64-linux-gnu-gdb<br></code></pre></td></tr></table></figure><p><strong>测试一下环境</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">riscv64-linux-gnu-gcc --version<br>qemu-system-riscv64 --version<br></code></pre></td></tr></table></figure><p>如果出现下图就说明成功了：</p><p><img src="/img/6.S081/riscv64.png" /></p><p><strong>安装运行xv6的模拟器:</strong></p><p>官网上的qemu-arch-extra已经被替换为了qemu-arch-extra-git。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> pacman -S qemu-arch-extra-git<br></code></pre></td></tr></table></figure><p>到这需要的环境就装完了<del>(不会装vscode建议退课)</del>。</p><h2 id="编译运行xv6">编译运行xv6</h2><p>参考：https://pdos.csail.mit.edu/6.828/2021/labs/util.html</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> git://g.csail.mit.edu/xv6-labs-2021<br><span class="hljs-built_in">cd</span> xv6-labs-2021<br></code></pre></td></tr></table></figure><p>课程里提到实验用的xv6和实际发布的不太一样，所以别下载github上的，用课程官网的这个。如果要其他年份的就把末尾的<code>xv6-labs-2021</code>改为其他年份就行。</p><p>可以发现master分支里啥也没有，我们先切换到lab1用到的<code>util</code>分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout util<br></code></pre></td></tr></table></figure><p>这时候<code>ls</code>一下就会出现xv6的源码了：</p><p><img src="/img/6.S081/utils.png" /></p><p>然后用<code>qemu</code>编译一下看看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make qemu<br></code></pre></td></tr></table></figure><p><img src="/img/6.S081/qemu.png" /></p><p>最后出现这几行就说明编译成功了，按<code>ctrl + a, x</code>退出模拟环境。</p><p><img src="/img/6.S081/boot.png" /></p><p>这里会遇到几个坑：</p><h3id="编译显示infinite-recursion-detected">编译显示<code>infinite recursion detected</code></h3><p><img src="/img/6.S081/error.png" /></p><p>解决方案见https://github.com/mit-pdos/xv6-riscv/pull/126。</p><p>由于实现的是操作系统，需要很高的代码可靠性，所以MIT在<code>Makefile</code>里设置了把所有警告都视为错误。在<code>user/sh.c</code>中<code>runcmd</code>前添加一行<code>__attribute__((noreturn))</code>即可。</p><p><img src="/img/6.S081/runcmd.png" /></p><h3 id="编译在最后一步卡住">编译在最后一步卡住</h3><p>如果用的是2020版的<code>xv6</code>，由于老版本的<code>qemu</code>和新版本的不兼容，可以使用<code>downgrage</code>来降级<code>qemu</code>.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> downgrade qemu-arch-extra<br></code></pre></td></tr></table></figure><p>选择<code>5.2.0</code>或以前的版本即可。</p><p>也可以用源码编译安装老版本的<code>qemu</code>,参考：https://www.xujintong.com/2023/12/24/187/</p><p><strong>PS：经过亲身试验，2021版和2020版在实验内容上一模一样，所以建议用2021版，这样就不用降级<code>qemu</code>。</strong></p><h2 id="配置vscode和clangd">配置VScode和clangd</h2><p>配中文、主题什么的就不说了。</p><p>需要安装的插件有两个：C/C++（用来配置GDB调试）、clangd(代码补全)。</p><p><img src="/img/6.S081/C-C++.png" /></p><p><img src="/img/6.S081/clangd.png" /></p><p>可以发现<code>clangd</code>找不到标准库和<code>xv6</code>的库，需要用<code>compile_commands.json</code>文件来指明，可以用<code>bear</code>包来自动生成。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> pacman -S bear<br>make clean <span class="hljs-comment"># 清空上一次编译的内容</span><br>bear -- make qemu<br></code></pre></td></tr></table></figure><p>然后<code>compile_commands.json</code>文件里就指明了编译所需头文件的路径：</p><p><img src="/img/6.S081/compile_commands.png" /></p><h2 id="配置代码自动调整格式可选">配置代码自动调整格式(可选)</h2><p><code>xv6</code>的代码风格也太古老了，看的特别不顺眼，所以用<code>llvm</code>的代码风格魔改了一下。</p><p>首先按<code>ctrl + ,</code>，进入<code>vscode</code>的设置，搜索<code>format on save</code>,打上钩，这样在按<code>ctrl + s</code>保存代码的时候就可以自动格式化代码。</p><p>然后在<code>xv6</code>的根目录新建文件<code>.clang-format</code>，借用一下这个老哥的文件:https://github.com/kehanXue/google-style-clang-format/blob/master/.clang-format。把里面的<code>.clang-format</code>复制到我们的文件里面就行，<code>tab-size</code>什么的不习惯2也可以改为4。</p><p>需要注意的是，不要配置自动为头文件排序，不然声明顺序不对会提示函数未声明。在<code>.clangd-format</code>里面设置<code>SortIncludes: false</code>。</p><h2 id="使用vscode-gdb调试">使用VScode + gdb调试</h2><p>用<code>terminal</code>调试效率太低了(也可能是我太菜了)，所以用<code>vscode</code>配置<code>launch.json</code>来用图形化界面。</p><p>详细解释参考：https://www.cnblogs.com/KatyuMarisaBlog/p/13727565.html，这里就不说细节了。</p><p>在<code>xv6</code>根目录新建目录<code>.vscode</code>，里面新建文件<code>launch.json</code>。把下面这一段东西复制进去：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0.2.0&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;configurations&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;debug xv6&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cppdbg&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;request&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;launch&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;program&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/kernel/kernel&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;args&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;stopAtEntry&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;cwd&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;miDebuggerServerAddress&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;localhost:26000&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;miDebuggerPath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/usr/bin/riscv64-linux-gnu-gdb&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;environment&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;externalConsole&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;MIMode&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;gdb&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;setupCommands&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                <span class="hljs-punctuation">&#123;</span><br>                    <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;pretty printing&quot;</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;text&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;-enable-pretty-printing&quot;</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;ignoreFailures&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br>                <span class="hljs-punctuation">&#125;</span><br>            <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;logging&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-comment">// &quot;engineLogging&quot;: true,</span><br>                <span class="hljs-comment">// &quot;programOutput&quot;: true,</span><br>            <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>注意<code>midDebuggerPath</code>这一行，如果你用的是<code>riscv64-linux-gnu-gdb</code>就填<code>riscv64-linux-gnu-gdb</code>，如果是<code>riscv64-unknown-elf-gcc</code>就填<code>riscv64-unknown-elf-gcc</code>，其他的同理。</p><p>之后运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make qemu-gdb<br></code></pre></td></tr></table></figure><p>来开启<code>qemu</code>的<code>gdb</code>接口，可以看到用的接口是<code>26000</code>。</p><p><img src="/img/6.S081/qemu-gdb.png" /></p><p>在<code>xv6</code>根目录会自动新增一个<code>gdbinit</code>文件，把文件里的<code>target remote 127.0.0.1:26000</code>行删除。</p><p><img src="/img/6.S081/gdbinit.png" /></p><p>每一次执行<code>make clean</code>时都要把这一行删除，目前没找到一劳永逸的办法。</p><p>然后在需要调试的文件里添加断点，按下<code>F5</code>，<code>gbd</code>正确停止到<code>kernel</code>的<code>main</code>函数里。</p><p><img src="/img/6.S081/gdb_main.png" /></p><p>在需要调试的代码前加断点，这里用第一个实验<code>sleep.c</code>为例：</p><p><img src="/img/6.S081/sleep_break.png" /></p><p><img src="/img/6.S081/break_point.png" /></p><p>可以看到断点是灰红色+空心的，说明<code>vscode</code>并没有正确切换符号表，我们打开调试控制台，输入<code>-exec file /user/_sleep</code>，然后就发现断点变红+实心了。</p><p><img src="/img/6.S081/exec.png" /></p><p><img src="/img/6.S081/bread_point_red.png" /></p><p>在<code>xv6</code>终端中输入<code>sleep 10</code>来运行程序，点击上方的继续按钮，<code>gdb</code>将会运行到断点处停下，然后就和调试其他程序一样用就行。</p><p><img src="/img/6.S081/sleep_10.png" /></p><p><img src="/img/6.S081/run.png" /></p><h2 id="关于提交lab">关于提交lab</h2><p>管理code参考：https://xv6.dgs.zone/labs/use_git/git1.html</p><p>主要说一说怎么提交。</p><p>首先在这个网站注册账号并复制<code>api-KEY</code>：https://6828.scripts.mit.edu/2021/handin.py/</p><p>将所有改动提交到<code>github</code>后，在根目录输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make handin<br></code></pre></td></tr></table></figure><p>之后会提示让输入<code>api-key</code>，复制进去回车就行。如果<code>api-key</code>修改了，可以在文件<code>myapi.key</code>同步修改即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;系统为Archlinux物理机，环境如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/6.S081/neofetch.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;使用的xv6版本为2021版，运行环境为vscode + clangd + gbd。</summary>
      
    
    
    
    <category term="6.S081" scheme="https://acmicpc.top/categories/6-S081/"/>
    
    
    <category term="6.S081" scheme="https://acmicpc.top/tags/6-S081/"/>
    
  </entry>
  
  <entry>
    <title>std::chrono时间库总结</title>
    <link href="https://acmicpc.top/2024/01/20/std-chrono%E6%97%B6%E9%97%B4%E5%BA%93%E6%80%BB%E7%BB%93/"/>
    <id>https://acmicpc.top/2024/01/20/std-chrono%E6%97%B6%E9%97%B4%E5%BA%93%E6%80%BB%E7%BB%93/</id>
    <published>2024-01-19T16:42:47.000Z</published>
    <updated>2024-08-11T16:06:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本概念">基本概念</h2><p>C++11中引入了一个新的关于时间的库，所有内容都包括在<code>std::chrono</code>中，使用时直接引用头文件<code>#include&lt;chrono&gt;</code>和命名空间<code>std::chrono</code>即可。</p><p><code>std::chrono</code>库中主要有3个概念，时钟(Clocks)、时间段(Duration)、时间点(timePoint)。</p><h3 id="时钟clocks">时钟(Clocks)</h3><p>顾名思义，就是和计时的相关类。主要就有3个，分别是：</p><ol type="1"><li><p>系统时钟(system_clock),和操作系统的系统时间同步的时钟，一般是unix时间，即从1970年1月1日到当前系统时间的时间间隔。例如系统时间是1970年1月2日23:59:59，那么返回的值即为<spanclass="math inline">\(24*60*60=86400\)</span>秒。如果系统时间发生改变，相应的值也会发生改变。一般就是用来读取当前的系统时间。</p></li><li><p>单调时钟(steady_clock),就类似秒表，每一次调用返回的值都会大于上一次调用的值，和系统的时间无关。用于程序计时尽量用steady_clock，可以防止在不同PC上运行导致的返回时间不准确。</p></li><li><p>高精度时钟(high_resolution_clock),提供拥有最短计数周期的时钟，在某些编译器中可能是std::steady_clock或std::system_clock的别名，并且在不同编译器中的实现可能有巨大差异，应该尽量避免使用。</p></li></ol><p>一般来说，我们使用的都是system_clock,steady_clock相比system_clock就少了两个静态成员函数：<code>to_time_t</code>和<code>from_time_t</code>。</p><p>下面是两个使用示例：</p><p>使用system_clock读取系统时间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctime&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std::chrono;<br><br>    duration&lt;<span class="hljs-type">int</span>, std::ratio&lt;<span class="hljs-number">60</span>*<span class="hljs-number">60</span>*<span class="hljs-number">24</span>&gt;&gt; oneDay&#123;<span class="hljs-number">1</span>&#125;;  <span class="hljs-comment">// 长度为1天的时间段，duration类在下面会说。</span><br>    system_clock::time_point today = system_clock::<span class="hljs-built_in">now</span>();<br>    system_clock::time_point tomorrow = today + oneDay; <span class="hljs-comment">// 都重载了加减运算符</span><br><br>    <span class="hljs-comment">// 需要转换为time_t类型</span><br>    std::<span class="hljs-type">time_t</span> curTime = system_clock::<span class="hljs-built_in">to_time_t</span>(today);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Today is: &quot;</span> &lt;&lt; <span class="hljs-built_in">ctime</span>(&amp;curTime);<br><br>    std::<span class="hljs-type">time_t</span> nextTime = system_clock::<span class="hljs-built_in">to_time_t</span>(tomorrow);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;tomorrow is: &quot;</span> &lt;&lt; <span class="hljs-built_in">ctime</span>(&amp;nextTime);<br>&#125;<br></code></pre></td></tr></table></figure><p>输出： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">Today is: Sat Jan 20 01:46:56 2024<br>tomorrow is: Sun Jan 21 01:46:56 2024<br></code></pre></td></tr></table></figure></p><p>记录函数的运行时间一般使用steady_clock： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctime&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std::chrono;<br><br>    steady_clock::time_point start = steady_clock::<span class="hljs-built_in">now</span>();<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">1000</span>;i ++) std::cout &lt;&lt; <span class="hljs-string">&#x27;*&#x27;</span>;<br>    std::cout &lt;&lt; std::endl;<br><br>    steady_clock::time_point end = steady_clock::<span class="hljs-built_in">now</span>();<br><br>    duration&lt;<span class="hljs-type">double</span>, std::ratio&lt;<span class="hljs-number">1</span>&gt;&gt; period = duration_cast&lt;duration&lt;<span class="hljs-type">double</span>&gt;&gt;(end - start);<br>    <span class="hljs-comment">// 直接调用构造函数初始化也行</span><br>    <span class="hljs-comment">// duration&lt;double, std::ratio&lt;1&gt;&gt; period(end-start);</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Took &quot;</span> &lt;&lt; period.<span class="hljs-built_in">count</span>() &lt;&lt; <span class="hljs-string">&quot; seconds&quot;</span> &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure> 输出：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Took 2.7105e-05 seconds<br></code></pre></td></tr></table></figure>注意，steady_clock没有<code>to_time_t</code>和<code>from_time_t</code>，只能提供基本计时操作。</p><h3 id="时间段durations">时间段(Durations)</h3><p>顾名思义就是表示一段持续的时间，比如1s、1min、1day等，需要指定单位，所以Duration需要提供一个模板来指定。</p><p>他的定义如下： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Rep</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Period</span> = std::ratio&lt;<span class="hljs-number">1</span>&gt;&gt; <span class="hljs-keyword">class</span> duration;<br></code></pre></td></tr></table></figure>其中<code>Period</code>就是用来表示时间段的单位，比如天、分钟、秒等。<code>Rep</code>就是实际用来存储数据类型。比如10秒，则<code>Period</code>就为<code>std::ratio&lt;1&gt;</code>,<code>Rep</code>就为<code>int</code>，数值为10。如果要表示10.0秒，则<code>Rep</code>就为<code>double</code>。一般</p><p><code>Period</code>类是<code>std::ratio</code>的别名，也就是一个分数(比率)，定义如下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-type">intmax_t</span> N, <span class="hljs-type">intmax_t</span> D = <span class="hljs-number">1</span>&gt; <span class="hljs-keyword">class</span> ratio;<br></code></pre></td></tr></table></figure>N表示分子，D表示分母，用秒作为基本单位。例如当N=1,D=1时候，就是1/1 =1s，当N=1，D=1000时，就是1/1000 = 1ms，当N=60，D=1时，就是60/1 =1min。</p><p>标准库定义了一些常见的时间段： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">using</span> nanoseconds = duration&lt;_GLIBCXX_CHRONO_INT64_T, ratio&lt;<span class="hljs-number">1</span>,<span class="hljs-number">1000000000</span>&gt;&gt;; <span class="hljs-comment">// 纳秒，使用至少64位的有符号整数存储</span><br><span class="hljs-keyword">using</span> microseconds = duration&lt;_GLIBCXX_CHRONO_INT64_T, ratio&lt;<span class="hljs-number">1</span>, <span class="hljs-number">1000000</span>&gt;&gt;; <span class="hljs-comment">// 微秒，使用至少55位的有符号整数存储</span><br><span class="hljs-keyword">using</span> milliseconds = duration&lt;_GLIBCXX_CHRONO_INT64_T, ratio&lt;<span class="hljs-number">1</span>, <span class="hljs-number">1000</span>&gt;&gt;; <span class="hljs-comment">// 毫秒，使用至少45位的有符号整数存储</span><br><span class="hljs-keyword">using</span> seconds = duration&lt;_GLIBCXX_CHRONO_INT64_T&gt;;<br><span class="hljs-comment">// 秒，使用长度不小于35位的有符号整数存储</span><br><span class="hljs-keyword">using</span> minutes = duration&lt;_GLIBCXX_CHRONO_INT64_T, ratio&lt;<span class="hljs-number">60</span>, <span class="hljs-number">1</span>&gt;&gt;; <span class="hljs-comment">// 分钟, 使用长度不小于29为的有符号整数存储。</span><br></code></pre></td></tr></table></figure>其他的参考：https://cplusplus.com/reference/chrono/duration/，懒得写了。</p><p>对于duration来说，一般有两种操作：</p><ol type="1"><li>时间的增减。</li></ol><p>duration重载了大多数运算符，可以直接进行运算： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// duration operators</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ratio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>    std::chrono::duration&lt;<span class="hljs-type">int</span>&gt; foo&#123;&#125;;<br>    std::<span class="hljs-function">chrono::duration&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">bar</span> <span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br><br>    <span class="hljs-comment">//                    counts: foo bar</span><br>    <span class="hljs-comment">//                            --- ---</span><br>    foo = bar;                 <span class="hljs-comment">// 10  10</span><br>    foo = foo + bar;           <span class="hljs-comment">// 20  10</span><br>    ++foo;                     <span class="hljs-comment">// 21  10</span><br>    --bar;                     <span class="hljs-comment">// 21   9</span><br>    foo *= <span class="hljs-number">2</span>;                  <span class="hljs-comment">// 42   9</span><br>    foo /= <span class="hljs-number">3</span>;                  <span class="hljs-comment">// 14   9</span><br>    bar += ( foo % bar );      <span class="hljs-comment">// 14  14</span><br><br>    std::cout &lt;&lt; std::boolalpha;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;foo==bar: &quot;</span> &lt;&lt; (foo==bar) &lt;&lt; std::endl; <span class="hljs-comment">// == 运算符比较两个时间段的值</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;foo: &quot;</span> &lt;&lt; foo.<span class="hljs-built_in">count</span>() &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;bar: &quot;</span> &lt;&lt; bar.<span class="hljs-built_in">count</span>() &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure> 输出：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">foo==bar: <span class="hljs-literal">true</span><br>foo: 14<br>bar: 14<br></code></pre></td></tr></table></figure> 2. 不同单位时间段的转换可以使用<code>duration_cast</code>函数来转换： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::<span class="hljs-function">chrono::seconds <span class="hljs-title">s</span> <span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;             <span class="hljs-comment">// 1 second</span><br>    std::chrono::milliseconds ms = std::chrono::<span class="hljs-built_in">duration_cast</span>&lt;std::chrono::milliseconds&gt; (s);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;ms: &quot;</span> &lt;&lt; ms.<span class="hljs-built_in">count</span>() &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;s: &quot;</span> &lt;&lt; s.<span class="hljs-built_in">count</span>() &lt;&lt; std::endl;<br><br>    ms += std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">2500</span>);  <span class="hljs-comment">// 3500 millisecond</span><br><br>    s = std::chrono::<span class="hljs-built_in">duration_cast</span>&lt;std::chrono::seconds&gt; (ms);<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;ms: &quot;</span> &lt;&lt; ms.<span class="hljs-built_in">count</span>() &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;s: &quot;</span> &lt;&lt; s.<span class="hljs-built_in">count</span>() &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure> 输出：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash：">ms: 1000<br>s: 1<br>ms: 3500<br>s: 3<br></code></pre></td></tr></table></figure></p><h3 id="时间点time_point">时间点(time_point)</h3><p>时间点表示一个确切的时间，例如：2024年1月20日1:49:53。时钟(clocks)返回的值就是一个时间点，两个时间点之间的差值就是一段时间(duration)。</p><p>时间点的定义如下： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Clock</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Duration</span> = <span class="hljs-keyword">typename</span> Clock::duration&gt; <span class="hljs-keyword">class</span> time_point;<br></code></pre></td></tr></table></figure>可以看出，标准库将时间点定义为：在基准时钟的起始时间加上一个时间段，一次来表示一个时间点。所以时间点都是基于基准时钟的起始时间来的。</p><p>常用的函数有：</p><ol type="1"><li><code>time_since_epoch()</code>: 返回基于起始时间的时间段。</li><li><code>time_point_cast()</code>:用来将时间点转换为基于同一个时钟，但为不同单位的时间点。</li></ol><p>一般使用时间点的场景就是类似clock的那种，记录两个时间点然后计时，或者转换为时间戳什么的。</p><p>时间点加减时间段返回一个新的时间点，时间点加减一个时间点返回一个时间段，和常识都一样，还是挺好理解。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基本概念&quot;&gt;基本概念&lt;/h2&gt;
&lt;p&gt;C++11中引入了一个新的关于时间的库，所有内容都包括在&lt;code&gt;std::chrono&lt;/code&gt;中，使用时直接引用头文件&lt;code&gt;#include&amp;lt;chrono&amp;gt;&lt;/code&gt;和命名空间&lt;code&gt;std</summary>
      
    
    
    
    <category term="modern-cpp" scheme="https://acmicpc.top/categories/modern-cpp/"/>
    
    
    <category term="modern-cpp" scheme="https://acmicpc.top/tags/modern-cpp/"/>
    
  </entry>
  
  <entry>
    <title>The 2022 ICPC Asia Xian Regional Contest</title>
    <link href="https://acmicpc.top/2023/09/06/The%202022%20ICPC%20Asia%20Xian%20Regional%20Contest/"/>
    <id>https://acmicpc.top/2023/09/06/The%202022%20ICPC%20Asia%20Xian%20Regional%20Contest/</id>
    <published>2023-09-06T10:11:21.000Z</published>
    <updated>2023-09-06T10:21:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>B题网络流看了好久都没看明白，这场撑死也只能6题T_T，但是6题还可能铁。🐔了。</p><hr /><h2 id="c---clone-ranran-cf104077-c"><ahref="https://codeforces.com/gym/104077/problem/C">C - Clone Ranran(CF104077 C)</a></h2><h3 id="题目大意">题目大意</h3><p>&lt;++&gt;</p><h3 id="解题思路">解题思路</h3><p>肯定是先复制然后一遍出题最优，枚举复制就行。</p><details><summary>神奇的代码</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> i64 = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    i64 a, b, c;<br>    std::cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br><br>    i64 ans = (<span class="hljs-number">1LL</span> &lt;&lt; <span class="hljs-number">60</span>);<br>    i64 add = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (i64 i = <span class="hljs-number">1</span>;i &lt;= c + c;i &lt;&lt;= <span class="hljs-number">1</span>) &#123;<br>        ans = std::<span class="hljs-built_in">min</span>(ans, <span class="hljs-number">1LL</span> * ((c + i - <span class="hljs-number">1</span>) / i) * b + add);<br>        add += a;<br>    &#125;<br>    <br>    std::cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>)-&gt;<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br><br>    <span class="hljs-type">int</span> tt = <span class="hljs-number">1</span>;<br>    std::cin &gt;&gt; tt;<br>    <span class="hljs-keyword">while</span> (tt --) <span class="hljs-built_in">solve</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></details><p><br></p><hr /><h2 id="f---hotel-cf104077-f"><ahref="https://codeforces.com/gym/104077/problem/F">F - Hotel (CF104077F)</a></h2><h3 id="题目大意-1">题目大意</h3><p>&lt;++&gt;</p><h3 id="解题思路-1">解题思路</h3><p>贪心</p><details><summary>神奇的代码</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> i64 = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, c1, c2;<br>    std::cin &gt;&gt; n &gt;&gt; c1 &gt;&gt; c2;<br><br>    i64 ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i ++) &#123;<br>        std::string s;<br>        std::cin &gt;&gt; s;<br>        <span class="hljs-keyword">if</span> (c1 * <span class="hljs-number">2</span> &lt;= c2) &#123;<br>            ans += <span class="hljs-number">3</span> * c1;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (s[<span class="hljs-number">0</span>] == s[<span class="hljs-number">1</span>] || s[<span class="hljs-number">0</span>] == s[<span class="hljs-number">2</span>] || s[<span class="hljs-number">1</span>] == s[<span class="hljs-number">2</span>]) ans += c2 + std::<span class="hljs-built_in">min</span>(c1, c2);<br>                <span class="hljs-keyword">else</span> ans += std::<span class="hljs-built_in">min</span>(<span class="hljs-number">3</span> * c1, <span class="hljs-number">3</span> * c2);<br>        &#125;<br>    &#125;<br><br>    std::cout &lt;&lt; ans &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>)-&gt;<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br><br>    <span class="hljs-type">int</span> tt = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// std::cin &gt;&gt; tt;</span><br>    <span class="hljs-keyword">while</span> (tt --) <span class="hljs-built_in">solve</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></details><p><br></p><hr /><h2 id="g---perfect-word-cf104077-g"><ahref="https://codeforces.com/gym/104077/problem/G">G - Perfect Word(CF104077 G)</a></h2><h3 id="题目大意-2">题目大意</h3><p>&lt;++&gt;</p><h3 id="解题思路-2">解题思路</h3><p>可以发现，当一个字符串是完美字符串时，他的任意一个子串也必须是完美字符串。判断掐头去尾的两个字符串是否是完美的就可以。</p><p>将所有字符串按长度从小到大排序，依次判断哪些是完美字符串维护最大值即可。</p><details><summary>神奇的代码</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><br><span class="hljs-keyword">using</span> i64 = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    std::cin &gt;&gt; n;<br><br>    <span class="hljs-function">std::vector&lt;std::string&gt; <span class="hljs-title">s</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i ++) &#123;<br>        std::cin &gt;&gt; s[i];<br>    &#125;<br><br>    std::<span class="hljs-built_in">sort</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>(), [&amp;](std::string &amp;a, std::string &amp;b) &#123;<br>        <span class="hljs-keyword">return</span> a.<span class="hljs-built_in">size</span>() &lt; b.<span class="hljs-built_in">size</span>();<br>    &#125;);<br><br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    std::map&lt;std::string, <span class="hljs-type">bool</span>&gt; mp;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i ++) &#123;<br>        <span class="hljs-keyword">if</span> (s[i].<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) &#123;<br>            mp[s[i]] = <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mp.<span class="hljs-built_in">count</span>(s[i].<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, s[i].<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>)) &amp;&amp; mp.<span class="hljs-built_in">count</span>(s[i].<span class="hljs-built_in">substr</span>(<span class="hljs-number">1</span>))) &#123;<br>            mp[s[i]] = <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">continue</span>;<br>        ans = std::<span class="hljs-built_in">max</span>(ans, <span class="hljs-built_in">int</span>(s[i].<span class="hljs-built_in">size</span>()));<br>    &#125;<br><br>    std::cout &lt;&lt; ans &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>)-&gt;<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br><br>    <span class="hljs-type">int</span> tt = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// std::cin &gt;&gt; tt;</span><br>    <span class="hljs-keyword">while</span> (tt --) <span class="hljs-built_in">solve</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></details><p><br></p><hr /><h2 id="j---strange-sum-cf104077-j"><ahref="https://codeforces.com/gym/104077/problem/J">J - Strange Sum(CF104077 J)</a></h2><h3 id="题目大意-3">题目大意</h3><p>&lt;++&gt;</p><h3 id="解题思路-3">解题思路</h3><p>去<span class="math inline">\(i\)</span>为<spanclass="math inline">\(n\)</span>显然可以取到整个区间。设<spanclass="math inline">\(a\)</span>为最大值，<spanclass="math inline">\(b\)</span>为次大值，答案一定为：</p><p><span class="math inline">\(ans = max(0, a, a + b)\)</span></p><details><summary>神奇的代码</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> i64 = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    std::cin &gt;&gt; n;<br><br>    <span class="hljs-function">std::vector&lt;i64&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i ++) &#123;<br>        std::cin &gt;&gt; a[i];<br>    &#125;<br><br>    std::<span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>(), std::<span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;());<br>    i64 ans = <span class="hljs-number">0</span>;<br>    ans = std::<span class="hljs-built_in">max</span>(ans, a[<span class="hljs-number">0</span>] + a[<span class="hljs-number">1</span>]);<br>    ans = std::<span class="hljs-built_in">max</span>(ans, a[<span class="hljs-number">0</span>]);<br><br>    std::cout &lt;&lt; ans &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>)-&gt;<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br><br>    <span class="hljs-type">int</span> tt = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// std::cin &gt;&gt; tt;</span><br>    <span class="hljs-keyword">while</span> (tt --) <span class="hljs-built_in">solve</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></details><p><br></p><hr /><h2 id="l---tree-cf104077-l"><ahref="https://codeforces.com/gym/104077/problem/L">L - Tree (CF104077L)</a></h2><h3 id="题目大意-4">题目大意</h3><p>&lt;++&gt;</p><h3 id="解题思路-4">解题思路</h3><p>每个好集合要么是一条链，要么是所有叶子节点。</p><p>可以一层一层的叶子节点删上去，不断维护当前有多少条链+删的层数最小即可。</p><p>求链用长链剖分也行，直接dfs判断当前层有多少叶子节点也行。</p><p>时间复杂度<span class="math inline">\(o(n)\)</span>.</p><details><summary>神奇的代码</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><br><span class="hljs-keyword">using</span> i64 = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    std::cin &gt;&gt; n;<br><br>    std::vector&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">g</span>(n + <span class="hljs-number">1</span>, std::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;());<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;i &lt;= n;i ++) &#123;<br>        <span class="hljs-type">int</span> x;<br>        std::cin &gt;&gt; x;<br>        g[i].<span class="hljs-built_in">emplace_back</span>(x);<br>        g[x].<span class="hljs-built_in">emplace_back</span>(i);<br>    &#125;<br><br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">cnt</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">dep</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>    std::function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; dfs = [&amp;](<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> fa) &#123;<br>        dep[u] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : g[u]) &#123;<br>            <span class="hljs-keyword">if</span> (v == fa) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-built_in">dfs</span>(v, u);<br>            dep[u] = std::<span class="hljs-built_in">max</span>(dep[u], dep[v] + <span class="hljs-number">1</span>);<br>        &#125;<br>        cnt[dep[u]] ++;<br>    &#125;;<br><br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);<br><br>    <span class="hljs-type">int</span> ans = (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++) &#123;<br>        ans = std::<span class="hljs-built_in">min</span>(ans, i + cnt[i] - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    std::cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>)-&gt;<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br><br>    <span class="hljs-type">int</span> tt = <span class="hljs-number">1</span>;<br>    std::cin &gt;&gt; tt;<br>    <span class="hljs-keyword">while</span> (tt --) <span class="hljs-built_in">solve</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></details><p><br></p><hr />]]></content>
    
    
    <summary type="html">我好菜啊</summary>
    
    
    
    <category term="算法题解" scheme="https://acmicpc.top/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="codeforces" scheme="https://acmicpc.top/tags/codeforces/"/>
    
  </entry>
  
  <entry>
    <title>AtCoder Beginner Contest 317</title>
    <link href="https://acmicpc.top/2023/09/01/AtCoder%20Beginner%20Contest%20317/"/>
    <id>https://acmicpc.top/2023/09/01/AtCoder%20Beginner%20Contest%20317/</id>
    <published>2023-09-01T12:01:28.000Z</published>
    <updated>2023-09-01T13:33:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="a---potions-abc317-a"><ahref="https://atcoder.jp/contests/abc317/tasks/abc317_a">A - Potions(abc317 A)</a></h2><h3 id="题目大意">题目大意</h3><h3 id="解题思路">解题思路</h3><details><summary>神奇的代码</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> i64 = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, h, x;<br>    std::cin &gt;&gt; n &gt;&gt; h &gt;&gt; x;<br><br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i ++) &#123;<br>        std::cin &gt;&gt; a[i];<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i ++) &#123;<br>        <span class="hljs-keyword">if</span> (h + a[i] &gt;= x) &#123;<br>            std::cout &lt;&lt; i + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>)-&gt;<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br><br>    <span class="hljs-type">int</span> tt = <span class="hljs-number">1</span>;<br>    std::cin &gt;&gt; tt;<br>    <span class="hljs-keyword">while</span> (tt --) <span class="hljs-built_in">solve</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></details><p><br></p><hr /><h2 id="b---missingno.-abc317-b"><ahref="https://atcoder.jp/contests/abc317/tasks/abc317_b">B - MissingNo.(abc317 B)</a></h2><h3 id="题目大意-1">题目大意</h3><p>&lt;++&gt;</p><h3 id="解题思路-1">解题思路</h3><p>&lt;++&gt;</p><details><summary>神奇的代码</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> i64 = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    std::cin &gt;&gt; n;<br><br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i ++) &#123;<br>        std::cin &gt;&gt; a[i];<br>    &#125;<br><br>    std::<span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; n;i ++) &#123;<br>        <span class="hljs-keyword">if</span> (a[i] != a[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>) &#123;<br>            std::cout &lt;&lt; a[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>    &#125;<br><br>    std::cout &lt;&lt; a[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>)-&gt;<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br><br>    <span class="hljs-type">int</span> tt = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// std::cin &gt;&gt; tt;</span><br>    <span class="hljs-keyword">while</span> (tt --) <span class="hljs-built_in">solve</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></details><p><br></p><hr /><h2 id="c---remembering-the-days-abc317-c"><ahref="https://atcoder.jp/contests/abc317/tasks/abc317_c">C - Rememberingthe Days (abc317 C)</a></h2><h3 id="题目大意-2">题目大意</h3><p>&lt;++&gt;</p><h3 id="解题思路-2">解题思路</h3><p>很裸的一个图上dfs，一直维护最大值就行。</p><details><summary>神奇的代码</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> i64 = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> PII = std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m;<br>    std::cin &gt;&gt; n &gt;&gt; m;<br><br>    std::vector&lt;std::vector&lt;PII&gt;&gt; <span class="hljs-built_in">g</span>(n + <span class="hljs-number">1</span>, std::<span class="hljs-built_in">vector</span>&lt;PII&gt;());<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; m;i ++) &#123;<br>        <span class="hljs-type">int</span> u, v, w;<br>        std::cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;<br>        g[u].<span class="hljs-built_in">emplace_back</span>(v, w);<br>        g[v].<span class="hljs-built_in">emplace_back</span>(u, w);<br>    &#125;<br><br>    i64 ans = <span class="hljs-number">0</span>;<br>    std::bitset&lt;20&gt; vis;<br>    std::function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; dfs = [&amp;](<span class="hljs-type">int</span> u, i64 res) &#123;<br>        ans = std::<span class="hljs-built_in">max</span>(ans, res);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;[v, w] : g[u]) &#123;<br>            <span class="hljs-keyword">if</span> (vis[v]) <span class="hljs-keyword">continue</span>;<br>            vis[v] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-built_in">dfs</span>(v, res + w);<br>            vis[v] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++) &#123;<br>        vis.<span class="hljs-built_in">reset</span>();<br>        vis[i] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-built_in">dfs</span>(i, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    std::cout &lt;&lt; ans &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>)-&gt;<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    <br>    <span class="hljs-type">int</span> tt = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// std::cin &gt;&gt; tt;</span><br>    <span class="hljs-keyword">while</span> (tt --) <span class="hljs-built_in">solve</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></details><p><br></p><hr /><h2 id="d---president-abc317-d"><ahref="https://atcoder.jp/contests/abc317/tasks/abc317_d">D - President(abc317 D)</a></h2><h3 id="题目大意-3">题目大意</h3><p>&lt;++&gt;</p><h3 id="解题思路-3">解题思路</h3><p>每个地区都有叛变或不叛变两种情况，所以考虑用背包。</p><p>由于Z的和很小，所以设<spanclass="math inline">\(dp[i][j]\)</span>为前<spanclass="math inline">\(i\)</span>个地区收获了<spanclass="math inline">\(j\)</span>张选票，需要叛变的人数。</p><p>然后正常<span class="math inline">\(0/1\)</span>就行。</p><details><summary>神奇的代码</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> i64 = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> PII = std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br><br><span class="hljs-keyword">constexpr</span> i64 INF = (<span class="hljs-number">1LL</span> &lt;&lt; <span class="hljs-number">60</span>);<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    std::cin &gt;&gt; n;<br><br>    i64 sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-function">std::vector&lt;i64&gt; <span class="hljs-title">x</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">y</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">z</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++) &#123;<br>        std::cin &gt;&gt; x[i] &gt;&gt; y[i] &gt;&gt; z[i];<br>        sum += z[i];<br>    &#125;<br><br>    <span class="hljs-function">std::vector&lt;i64&gt; <span class="hljs-title">dp</span><span class="hljs-params">(sum + <span class="hljs-number">1</span>, INF)</span></span>;<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = sum;j &gt;= z[i];j --) &#123;<br>            i64 cost = std::<span class="hljs-built_in">max</span>(<span class="hljs-number">0LL</span>, (x[i] + y[i] + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> - x[i]);<br>            dp[j] = std::<span class="hljs-built_in">min</span>(dp[j], dp[j - z[i]] + cost);<br>        &#125;<br>    &#125;<br><br>    i64 ans = *std::<span class="hljs-built_in">min_element</span>(dp.<span class="hljs-built_in">begin</span>() + (sum + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>, dp.<span class="hljs-built_in">end</span>());<br>    std::cout &lt;&lt; ans &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>)-&gt;<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br><br>    <span class="hljs-type">int</span> tt = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// std::cin &gt;&gt; tt;</span><br>    <span class="hljs-keyword">while</span> (tt --) <span class="hljs-built_in">solve</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></details><p><br></p><hr /><h2 id="e---avoid-eye-contact-abc317-e"><ahref="https://atcoder.jp/contests/abc317/tasks/abc317_e">E - Avoid EyeContact (abc317 E)</a></h2><h3 id="题目大意-4">题目大意</h3><p>&lt;++&gt;</p><h3 id="解题思路-4">解题思路</h3><p>奶奶的还是一题dfs，只不过非常💩。认真判条件就行。</p><details><summary>神奇的代码</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> i64 = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> PII = std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br><br><span class="hljs-keyword">constexpr</span> i64 INF = (<span class="hljs-number">1LL</span> &lt;&lt; <span class="hljs-number">60</span>);<br><span class="hljs-keyword">constexpr</span> std::array&lt;<span class="hljs-type">int</span>, 4&gt; dy = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br><span class="hljs-keyword">constexpr</span> std::array&lt;<span class="hljs-type">int</span>, 4&gt; dx = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>    <span class="hljs-type">int</span> x, y, step;<br>    <span class="hljs-built_in">node</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-built_in">node</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> step) : <span class="hljs-built_in">x</span>(x), <span class="hljs-built_in">y</span>(y), <span class="hljs-built_in">step</span>(step) &#123;&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m;<br>    std::cin &gt;&gt; n &gt;&gt; m;<br><br>    <span class="hljs-type">int</span> sx = &#123;&#125;, sy = &#123;&#125;, ex = &#123;&#125;, ey = &#123;&#125;;<br>    std::vector&lt;PII&gt; view;<br>    std::vector&lt;std::vector&lt;<span class="hljs-type">char</span>&gt;&gt; <span class="hljs-built_in">a</span>(n + <span class="hljs-number">1</span>, std::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">char</span>&gt;(m + <span class="hljs-number">1</span>));<br>    std::vector&lt;std::vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">vis</span>(n + <span class="hljs-number">1</span>, std::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(m + <span class="hljs-number">1</span>));<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= m;j ++) &#123;<br>            std::cin &gt;&gt; a[i][j];<br>            <span class="hljs-keyword">if</span> (a[i][j] == <span class="hljs-string">&#x27;S&#x27;</span>) &#123;<br>                sx = i; sy = j;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a[i][j] == <span class="hljs-string">&#x27;G&#x27;</span>) &#123;<br>                ex = i; ey = j;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a[i][j] == <span class="hljs-string">&#x27;&gt;&#x27;</span> || a[i][j] == <span class="hljs-string">&#x27;&lt;&#x27;</span> || a[i][j] == <span class="hljs-string">&#x27;v&#x27;</span> || a[i][j] == <span class="hljs-string">&#x27;^&#x27;</span>) &#123;<br>                view.<span class="hljs-built_in">emplace_back</span>(i, j);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a[i][j] == <span class="hljs-string">&#x27;#&#x27;</span>) &#123;<br>                vis[i][j] = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;[x, y] : view) &#123;<br>        vis[x][y] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (a[x][y] == <span class="hljs-string">&#x27;&gt;&#x27;</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = y + <span class="hljs-number">1</span>;i &lt;= m;i ++) &#123;<br>                <span class="hljs-keyword">if</span> (a[x][i] == <span class="hljs-string">&#x27;.&#x27;</span> || a[x][i] == <span class="hljs-string">&#x27;S&#x27;</span> || a[x][i] == <span class="hljs-string">&#x27;G&#x27;</span>) vis[x][i] = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a[x][y] == <span class="hljs-string">&#x27;&lt;&#x27;</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = y - <span class="hljs-number">1</span>;i &gt;= <span class="hljs-number">1</span>;i --) &#123;<br>                <span class="hljs-keyword">if</span> (a[x][i] == <span class="hljs-string">&#x27;.&#x27;</span> || a[x][i] == <span class="hljs-string">&#x27;S&#x27;</span> || a[x][i] == <span class="hljs-string">&#x27;G&#x27;</span>) vis[x][i] = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a[x][y] == <span class="hljs-string">&#x27;v&#x27;</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = x + <span class="hljs-number">1</span>;i &lt;= n;i ++) &#123;<br>                <span class="hljs-keyword">if</span> (a[i][y] == <span class="hljs-string">&#x27;.&#x27;</span> || a[i][y] == <span class="hljs-string">&#x27;S&#x27;</span> || a[x][i] == <span class="hljs-string">&#x27;G&#x27;</span>) vis[i][y] = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a[x][y] == <span class="hljs-string">&#x27;^&#x27;</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = x - <span class="hljs-number">1</span>;i &gt;= <span class="hljs-number">1</span>;i --) &#123;<br>                <span class="hljs-keyword">if</span> (a[i][y] == <span class="hljs-string">&#x27;.&#x27;</span> || a[i][y] == <span class="hljs-string">&#x27;S&#x27;</span> || a[x][i] == <span class="hljs-string">&#x27;G&#x27;</span>) vis[i][y] = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">auto</span> bfs = [&amp;](<span class="hljs-type">void</span>) &#123;<br>        std::queue&lt;node&gt; q;<br>        q.<span class="hljs-built_in">emplace</span>(sx, sy, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">auto</span> [x, y, step] = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> (x == ex &amp;&amp; y == ey) <span class="hljs-keyword">return</span> step;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">4</span>;i ++) &#123;<br>                <span class="hljs-type">int</span> xx = x + dx[i], yy = y + dy[i];<br>                <span class="hljs-keyword">if</span> (xx == ex &amp;&amp; yy == ey) <span class="hljs-keyword">return</span> step + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (xx &lt; <span class="hljs-number">1</span> || xx &gt; n || yy &lt; <span class="hljs-number">1</span> || yy &gt; m) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span> (vis[xx][yy]) <span class="hljs-keyword">continue</span>;<br>                vis[xx][yy] = <span class="hljs-literal">true</span>;<br>                q.<span class="hljs-built_in">emplace</span>(xx, yy, step + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;;<br><br>    <span class="hljs-type">int</span> ans = <span class="hljs-built_in">bfs</span>();<br>    std::cout &lt;&lt; ans &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>)-&gt;<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br><br>    <span class="hljs-type">int</span> tt = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// std::cin &gt;&gt; tt;</span><br>    <span class="hljs-keyword">while</span> (tt --) <span class="hljs-built_in">solve</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></details><p><br></p><hr /><h2 id="f---nim-abc317-f"><ahref="https://atcoder.jp/contests/abc317/tasks/abc317_f">F - Nim (abc317F)</a></h2><h3 id="题目大意-5">题目大意</h3><p>&lt;++&gt;</p><h3 id="解题思路-5">解题思路</h3><p>计数DP，不知道怎么描述。</p><details><summary>神奇的代码</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> i64 = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> T <span class="hljs-title">power</span><span class="hljs-params">(T a, i64 b)</span> </span>&#123;<br>    T res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (; b; b /= <span class="hljs-number">2</span>, a *= a) &#123;<br>        <span class="hljs-keyword">if</span> (b % <span class="hljs-number">2</span>) &#123;<br>            res *= a;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> i64 <span class="hljs-title">mul</span><span class="hljs-params">(i64 a, i64 b, i64 p)</span> </span>&#123;<br>    i64 res = a * b - <span class="hljs-built_in">i64</span>(<span class="hljs-number">1.L</span> * a * b / p) * p;<br>    res %= p;<br>    <span class="hljs-keyword">if</span> (res &lt; <span class="hljs-number">0</span>) &#123;<br>        res += p;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-keyword">template</span>&lt;i64 P&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MLong</span> &#123;<br>    i64 x;<br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">MLong</span><span class="hljs-params">()</span> : x&#123;</span>&#125; &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">MLong</span><span class="hljs-params">(i64 x)</span> : x&#123;</span><span class="hljs-built_in">norm</span>(x % <span class="hljs-built_in">getMod</span>())&#125; &#123;&#125;<br>    <br>    <span class="hljs-type">static</span> i64 Mod;<br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">static</span> i64 <span class="hljs-title">getMod</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (P &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> P;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> Mod;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">setMod</span><span class="hljs-params">(i64 Mod_)</span> </span>&#123;<br>        Mod = Mod_;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> i64 <span class="hljs-title">norm</span><span class="hljs-params">(i64 x)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span>) &#123;<br>            x += <span class="hljs-built_in">getMod</span>();<br>        &#125;<br>        <span class="hljs-keyword">if</span> (x &gt;= <span class="hljs-built_in">getMod</span>()) &#123;<br>            x -= <span class="hljs-built_in">getMod</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> i64 <span class="hljs-title">val</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">i64</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br>    <span class="hljs-keyword">constexpr</span> MLong <span class="hljs-keyword">operator</span>-() <span class="hljs-type">const</span> &#123;<br>        MLong res;<br>        res.x = <span class="hljs-built_in">norm</span>(<span class="hljs-built_in">getMod</span>() - x);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> MLong <span class="hljs-title">inv</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-built_in">assert</span>(x != <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">power</span>(*<span class="hljs-keyword">this</span>, <span class="hljs-built_in">getMod</span>() - <span class="hljs-number">2</span>);<br>    &#125;<br>    <span class="hljs-keyword">constexpr</span> MLong &amp;<span class="hljs-keyword">operator</span>*=(MLong rhs) &amp; &#123;<br>        x = <span class="hljs-built_in">mul</span>(x, rhs.x, <span class="hljs-built_in">getMod</span>());<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    <span class="hljs-keyword">constexpr</span> MLong &amp;<span class="hljs-keyword">operator</span>+=(MLong rhs) &amp; &#123;<br>        x = <span class="hljs-built_in">norm</span>(x + rhs.x);<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    <span class="hljs-keyword">constexpr</span> MLong &amp;<span class="hljs-keyword">operator</span>-=(MLong rhs) &amp; &#123;<br>        x = <span class="hljs-built_in">norm</span>(x - rhs.x);<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    <span class="hljs-keyword">constexpr</span> MLong &amp;<span class="hljs-keyword">operator</span>/=(MLong rhs) &amp; &#123;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span> *= rhs.<span class="hljs-built_in">inv</span>();<br>    &#125;<br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">constexpr</span> MLong <span class="hljs-keyword">operator</span>*(MLong lhs, MLong rhs) &#123;<br>        MLong res = lhs;<br>        res *= rhs;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">constexpr</span> MLong <span class="hljs-keyword">operator</span>+(MLong lhs, MLong rhs) &#123;<br>        MLong res = lhs;<br>        res += rhs;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">constexpr</span> MLong <span class="hljs-keyword">operator</span>-(MLong lhs, MLong rhs) &#123;<br>        MLong res = lhs;<br>        res -= rhs;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">constexpr</span> MLong <span class="hljs-keyword">operator</span>/(MLong lhs, MLong rhs) &#123;<br>        MLong res = lhs;<br>        res /= rhs;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">constexpr</span> std::istream &amp;<span class="hljs-keyword">operator</span>&gt;&gt;(std::istream &amp;is, MLong &amp;a) &#123;<br>        i64 v;<br>        is &gt;&gt; v;<br>        a = <span class="hljs-built_in">MLong</span>(v);<br>        <span class="hljs-keyword">return</span> is;<br>    &#125;<br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">constexpr</span> std::ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream &amp;os, <span class="hljs-type">const</span> MLong &amp;a) &#123;<br>        <span class="hljs-keyword">return</span> os &lt;&lt; a.<span class="hljs-built_in">val</span>();<br>    &#125;<br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(MLong lhs, MLong rhs) &#123;<br>        <span class="hljs-keyword">return</span> lhs.<span class="hljs-built_in">val</span>() == rhs.<span class="hljs-built_in">val</span>();<br>    &#125;<br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(MLong lhs, MLong rhs) &#123;<br>        <span class="hljs-keyword">return</span> lhs.<span class="hljs-built_in">val</span>() != rhs.<span class="hljs-built_in">val</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;&gt;<br>i64 MLong&lt;<span class="hljs-number">0LL</span>&gt;::Mod = <span class="hljs-built_in">i64</span>(<span class="hljs-number">1E18</span>) + <span class="hljs-number">9</span>;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">int</span> P&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MInt</span> &#123;<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">MInt</span><span class="hljs-params">()</span> : x&#123;</span>&#125; &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">MInt</span><span class="hljs-params">(i64 x)</span> : x&#123;</span><span class="hljs-built_in">norm</span>(x % <span class="hljs-built_in">getMod</span>())&#125; &#123;&#125;<br>    <br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> Mod;<br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">getMod</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (P &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> P;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> Mod;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">setMod</span><span class="hljs-params">(<span class="hljs-type">int</span> Mod_)</span> </span>&#123;<br>        Mod = Mod_;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">norm</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span>) &#123;<br>            x += <span class="hljs-built_in">getMod</span>();<br>        &#125;<br>        <span class="hljs-keyword">if</span> (x &gt;= <span class="hljs-built_in">getMod</span>()) &#123;<br>            x -= <span class="hljs-built_in">getMod</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">val</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">int</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br>    <span class="hljs-keyword">constexpr</span> MInt <span class="hljs-keyword">operator</span>-() <span class="hljs-type">const</span> &#123;<br>        MInt res;<br>        res.x = <span class="hljs-built_in">norm</span>(<span class="hljs-built_in">getMod</span>() - x);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> MInt <span class="hljs-title">inv</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-built_in">assert</span>(x != <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">power</span>(*<span class="hljs-keyword">this</span>, <span class="hljs-built_in">getMod</span>() - <span class="hljs-number">2</span>);<br>    &#125;<br>    <span class="hljs-keyword">constexpr</span> MInt &amp;<span class="hljs-keyword">operator</span>*=(MInt rhs) &amp; &#123;<br>        x = <span class="hljs-number">1LL</span> * x * rhs.x % <span class="hljs-built_in">getMod</span>();<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    <span class="hljs-keyword">constexpr</span> MInt &amp;<span class="hljs-keyword">operator</span>+=(MInt rhs) &amp; &#123;<br>        x = <span class="hljs-built_in">norm</span>(x + rhs.x);<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    <span class="hljs-keyword">constexpr</span> MInt &amp;<span class="hljs-keyword">operator</span>-=(MInt rhs) &amp; &#123;<br>        x = <span class="hljs-built_in">norm</span>(x - rhs.x);<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    <span class="hljs-keyword">constexpr</span> MInt &amp;<span class="hljs-keyword">operator</span>/=(MInt rhs) &amp; &#123;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span> *= rhs.<span class="hljs-built_in">inv</span>();<br>    &#125;<br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">constexpr</span> MInt <span class="hljs-keyword">operator</span>*(MInt lhs, MInt rhs) &#123;<br>        MInt res = lhs;<br>        res *= rhs;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">constexpr</span> MInt <span class="hljs-keyword">operator</span>+(MInt lhs, MInt rhs) &#123;<br>        MInt res = lhs;<br>        res += rhs;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">constexpr</span> MInt <span class="hljs-keyword">operator</span>-(MInt lhs, MInt rhs) &#123;<br>        MInt res = lhs;<br>        res -= rhs;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">constexpr</span> MInt <span class="hljs-keyword">operator</span>/(MInt lhs, MInt rhs) &#123;<br>        MInt res = lhs;<br>        res /= rhs;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">constexpr</span> std::istream &amp;<span class="hljs-keyword">operator</span>&gt;&gt;(std::istream &amp;is, MInt &amp;a) &#123;<br>        i64 v;<br>        is &gt;&gt; v;<br>        a = <span class="hljs-built_in">MInt</span>(v);<br>        <span class="hljs-keyword">return</span> is;<br>    &#125;<br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">constexpr</span> std::ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream &amp;os, <span class="hljs-type">const</span> MInt &amp;a) &#123;<br>        <span class="hljs-keyword">return</span> os &lt;&lt; a.<span class="hljs-built_in">val</span>();<br>    &#125;<br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(MInt lhs, MInt rhs) &#123;<br>        <span class="hljs-keyword">return</span> lhs.<span class="hljs-built_in">val</span>() == rhs.<span class="hljs-built_in">val</span>();<br>    &#125;<br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(MInt lhs, MInt rhs) &#123;<br>        <span class="hljs-keyword">return</span> lhs.<span class="hljs-built_in">val</span>() != rhs.<span class="hljs-built_in">val</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;&gt;<br><span class="hljs-type">int</span> MInt&lt;<span class="hljs-number">0</span>&gt;::Mod = <span class="hljs-number">998244353</span>;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">int</span> V, <span class="hljs-type">int</span> P&gt;<br><span class="hljs-keyword">constexpr</span> MInt&lt;P&gt; CInv = <span class="hljs-built_in">MInt</span>&lt;P&gt;(V).<span class="hljs-built_in">inv</span>();<br><br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> P = <span class="hljs-number">998244353</span>;<br><span class="hljs-keyword">using</span> Z = MInt&lt;P&gt;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    <br>    i64 N;<br>    std::cin &gt;&gt; N;<br>    N++;<br>    <br>    <span class="hljs-type">int</span> A1, A2, A3;<br>    std::cin &gt;&gt; A1 &gt;&gt; A2 &gt;&gt; A3;<br>    <br>    Z ans = <span class="hljs-number">0</span>;<br>    Z dp[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>][<span class="hljs-number">2</span>][<span class="hljs-number">10</span>][<span class="hljs-number">10</span>][<span class="hljs-number">10</span>];<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> t = <span class="hljs-number">59</span>; t &gt;= <span class="hljs-number">0</span>; t--) &#123;<br>        <span class="hljs-type">int</span> n = N &gt;&gt; t &amp; <span class="hljs-number">1</span>;<br>        Z g[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>][<span class="hljs-number">2</span>][<span class="hljs-number">10</span>][<span class="hljs-number">10</span>][<span class="hljs-number">10</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> l1 : &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> l2 : &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> l3 : &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> m1 = <span class="hljs-number">0</span>; m1 &lt; A1; m1++) &#123;<br>                        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> m2 = <span class="hljs-number">0</span>; m2 &lt; A2; m2++) &#123;<br>                            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> m3 = <span class="hljs-number">0</span>; m3 &lt; A3; m3++) &#123;<br>                                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x1 = <span class="hljs-number">0</span>; x1 &lt;= (l1 ? <span class="hljs-number">1</span> : n); x1++) &#123;<br>                                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x2 = <span class="hljs-number">0</span>; x2 &lt;= (l2 ? <span class="hljs-number">1</span> : n); x2++) &#123;<br>                                        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x3 = <span class="hljs-number">0</span>; x3 &lt;= (l3 ? <span class="hljs-number">1</span> : n); x3++) &#123;<br>                                            <span class="hljs-keyword">if</span> ((x1 ^ x2 ^ x3) == <span class="hljs-number">0</span>) &#123;<br>                                                g[l1 || x1 &lt; n][l2 || x2 &lt; n][l3 || x3 &lt; n][(m1 * <span class="hljs-number">2</span> + x1) % A1][(m2 * <span class="hljs-number">2</span> + x2) % A2][(m3 * <span class="hljs-number">2</span> + x3) % A3]<br>                                                    += dp[l1][l2][l3][m1][m2][m3];<br>                                            &#125;<br>                                        &#125;<br>                                    &#125;<br>                                &#125;<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        std::<span class="hljs-built_in">swap</span>(dp, g);<br>    &#125;<br>    <br>    ans = dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>    N--;<br>    ans -= N / std::<span class="hljs-built_in">lcm</span>(A1, A2);<br>    ans -= N / std::<span class="hljs-built_in">lcm</span>(A1, A3);<br>    ans -= N / std::<span class="hljs-built_in">lcm</span>(A2, A3);<br>    ans -= <span class="hljs-number">1</span>;<br>    std::cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></details><p><br></p><hr /><h2 id="g---rearranging-abc317-g"><ahref="https://atcoder.jp/contests/abc317/tasks/abc317_g">G - Rearranging(abc317 G)</a></h2><h3 id="题目大意-6">题目大意</h3><p>&lt;++&gt;</p><h3 id="解题思路-6">解题思路</h3><p>看题解是什么二分图完美匹配+最大流。先学学网络流再来补</p><details><summary>神奇的代码</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br></code></pre></td></tr></table></figure></details><p><br></p><hr /><h2 id="ex---walk-abc317-ex"><ahref="https://atcoder.jp/contests/abc317/tasks/abc317_h">Ex - Walk(abc317 Ex)</a></h2><h3 id="题目大意-7">题目大意</h3><p>&lt;++&gt;</p><h3 id="解题思路-7">解题思路</h3><p>&lt;++&gt;</p><details><summary>神奇的代码</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br></code></pre></td></tr></table></figure></details><p><br></p><hr />]]></content>
    
    
    <summary type="html">我好菜啊</summary>
    
    
    
    <category term="算法题解" scheme="https://acmicpc.top/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="atcoder" scheme="https://acmicpc.top/tags/atcoder/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces Round 894 (Div. 3)</title>
    <link href="https://acmicpc.top/2023/08/30/Codeforces%20Round%20894%20(Div.%203)/"/>
    <id>https://acmicpc.top/2023/08/30/Codeforces%20Round%20894%20(Div.%203)/</id>
    <published>2023-08-30T08:41:04.000Z</published>
    <updated>2023-08-30T10:09:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="a---gift-carpet-cf1862-a"><ahref="https://codeforces.com/contest/1862/problem/A">A - Gift Carpet(CF1862 A)</a></h2><h3 id="题目大意">题目大意</h3><p>看是不是能拿出四列，按顺序出现"vika"四个字母。</p><h3 id="解题思路">解题思路</h3><p>不解释</p><details><summary>神奇的代码</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span>  i64 = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m;<br>    std::cin &gt;&gt; n &gt;&gt; m;<br><br>    std::vector&lt;std::vector&lt;<span class="hljs-type">char</span>&gt;&gt; <span class="hljs-built_in">a</span>(n + <span class="hljs-number">1</span>, std::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">char</span>&gt;(m + <span class="hljs-number">1</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= m;j ++) &#123;<br>            std::cin &gt;&gt; a[i][j];<br>        &#125;<br>    &#125;<br><br>    std::string res = <span class="hljs-string">&quot;#vika&quot;</span>;<br>    <span class="hljs-type">int</span> pos = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= m;j ++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++) &#123;<br>            <span class="hljs-keyword">if</span> (a[i][j] == res[pos]) &#123;<br>                pos ++;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (pos == <span class="hljs-number">5</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;YES&quot;</span> &lt;&lt; std::endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-type">int</span> tt = <span class="hljs-number">1</span>;<br>    std::cin &gt;&gt; tt;<br>    <span class="hljs-keyword">while</span> (tt --) <span class="hljs-built_in">solve</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></details><p><br></p><hr /><h2 id="b---sequence-game-cf1862-b"><ahref="https://codeforces.com/contest/1862/problem/B">B - Sequence Game(CF1862 B)</a></h2><h3 id="题目大意-1">题目大意</h3><h3 id="解题思路-1">解题思路</h3><p>如果一段区间是递增的，就已经符合题意，不用动。如果不是递增的，在前面复制一份就形成递增了。</p><details><summary>神奇的代码</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span>  i64 = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    std::cin &gt;&gt; n;<br><br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i ++) &#123;<br>        std::cin &gt;&gt; a[i];<br>    &#125;<br><br>    std::vector&lt;<span class="hljs-type">int</span>&gt; b;<br>    b.<span class="hljs-built_in">emplace_back</span>(a.<span class="hljs-built_in">front</span>());<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; n;i ++) &#123;<br>        <span class="hljs-keyword">if</span> (a[i - <span class="hljs-number">1</span>] &gt; a[i]) b.<span class="hljs-built_in">emplace_back</span>(a[i]);        <br>        b.<span class="hljs-built_in">emplace_back</span>(a[i]);<br>    &#125;<br><br>    std::cout &lt;&lt; b.<span class="hljs-built_in">size</span>() &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> &amp;item : b) &#123;<br>        std::cout &lt;&lt; item &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>    &#125;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-type">int</span> tt = <span class="hljs-number">1</span>;<br>    std::cin &gt;&gt; tt;<br>    <span class="hljs-keyword">while</span> (tt --) <span class="hljs-built_in">solve</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></details><p><br></p><hr /><h2 id="c---flower-city-fence-cf1862-c"><ahref="https://codeforces.com/contest/1862/problem/C">C - Flower CityFence (CF1862 C)</a></h2><h3 id="题目大意-2">题目大意</h3><p>&lt;++&gt;</p><h3 id="解题思路-2">解题思路</h3><p>树状数组维护一下每一列的方块数，然后和原数组比较就行。</p><details><summary>神奇的代码</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstddef&gt;</span></span><br><br><span class="hljs-keyword">using</span>  i64 = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">FenwickTree</span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    std::vector&lt;T&gt; bit;<br><br>    <span class="hljs-comment">// constructors</span><br>    <span class="hljs-built_in">FenwickTree</span>(<span class="hljs-type">int</span> _n) : <span class="hljs-built_in">n</span>(_n), <span class="hljs-built_in">bit</span>(_n + <span class="hljs-number">1</span>) &#123;&#125;<br>    <span class="hljs-built_in">FenwickTree</span>(std::vector&lt;T&gt; &amp;a) : <span class="hljs-built_in">FenwickTree</span>(a.<span class="hljs-built_in">size</span>())&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">size_t</span> i = <span class="hljs-number">1</span>;i &lt;= a.<span class="hljs-built_in">size</span>();i ++)<br>            <span class="hljs-built_in">update</span>(i, a[i]);<br>    &#125;<br><br>    <span class="hljs-comment">// Operations</span><br>    <span class="hljs-function">T <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> idx)</span></span>&#123;<br>        T res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = idx;i != <span class="hljs-number">0</span>; i -= i &amp; -i)<br>            res += bit[i];<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> idx, <span class="hljs-type">int</span> delta)</span></span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = idx;i &lt;= n;i += i &amp; -i)<br>            bit[i] += delta;<br>    &#125;<br><br>    <span class="hljs-function">T <span class="hljs-title">range_quary</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(r) - <span class="hljs-built_in">query</span>(l - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">range_update</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> delta)</span></span>&#123;<br>        <span class="hljs-built_in">update</span>(l, delta);<br>        <span class="hljs-built_in">update</span>(r + <span class="hljs-number">1</span>, -delta);<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    std::cin &gt;&gt; n;<br><br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++) &#123;<br>        std::cin &gt;&gt; a[i];<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (a[<span class="hljs-number">1</span>] &gt; n) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br><br>    <span class="hljs-function">FenwickTree&lt;i64&gt; <span class="hljs-title">bit</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++) &#123;<br>        bit.<span class="hljs-built_in">range_update</span>(<span class="hljs-number">1</span>, a[i], <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++) &#123;<br>        i64 res = bit.<span class="hljs-built_in">query</span>(i);<br>        <span class="hljs-keyword">if</span> (res != a[i]) &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>    &#125;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;YES&quot;</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-type">int</span> tt = <span class="hljs-number">1</span>;<br>    std::cin &gt;&gt; tt;<br>    <span class="hljs-keyword">while</span> (tt --) <span class="hljs-built_in">solve</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></details><p><br></p><hr /><h2 id="d---ice-cream-balls-cf1862-d"><ahref="https://codeforces.com/contest/1862/problem/D">D - Ice Cream Balls(CF1862 D)</a></h2><h3 id="题目大意-3">题目大意</h3><p>&lt;++&gt;</p><h3 id="解题思路-3">解题思路</h3><p>首先要最少，肯定所有数字不一样的时候最少。可以先二分来找到刚好<spanclass="math inline">\(C_i^2\)</span>小于n的<spanclass="math inline">\(i\)</span>。 然后考虑要添加到恰好n份，只需要添加$n - C_i^i $个相同的数字即可。</p><details><summary>神奇的代码</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span>  i64 = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    i64 n;<br>    std::cin &gt;&gt; n;<br><br>    <span class="hljs-keyword">auto</span> check = [&amp;](i64 x) &#123;<br>        i64 res = x * (x - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">return</span> res &gt;= n;<br>    &#125;;<br><br>    i64 l = <span class="hljs-number">2</span>, r = <span class="hljs-number">2648956421</span>;<br>    <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>        <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    i64 res = l * (l - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (res == n) &#123;<br>        std::cout &lt;&lt; l &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (res &gt; n) &#123;<br>        res = (l - <span class="hljs-number">1</span>) * (l - <span class="hljs-number">2</span>) / <span class="hljs-number">2</span>;<br>        std::cout &lt;&lt; n - res + l - <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-type">int</span> tt = <span class="hljs-number">1</span>;<br>    std::cin &gt;&gt; tt;<br>    <span class="hljs-keyword">while</span> (tt --) <span class="hljs-built_in">solve</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></details><p><br></p><hr /><h2 id="e---kolya-and-movie-theatre-cf1862-e"><ahref="https://codeforces.com/contest/1862/problem/E">E - Kolya and MovieTheatre (CF1862 E)</a></h2><h3 id="题目大意-4">题目大意</h3><p>&lt;++&gt;</p><h3 id="解题思路-4">解题思路</h3><p>注意到最后一场电影在第<spanclass="math inline">\(i\)</span>天看，则少的舒适度一定为<spanclass="math inline">\(d * i\)</span>。所以只需要求出前<spanclass="math inline">\(m\)</span>大的数的和即可。 枚举<spanclass="math inline">\(i\)</span>, 维护以下<spanclass="math inline">\(1~i\)</span>中的前<spanclass="math inline">\(m\)</span>大数的和，最后求出最大值即可。</p><details><summary>神奇的代码</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><br><span class="hljs-keyword">using</span>  i64 = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m, d;<br>    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; d;<br><br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++) &#123;<br>        std::cin &gt;&gt; a[i];<br>    &#125;<br><br>    i64 ans = <span class="hljs-number">0</span>, sum = <span class="hljs-number">0</span>;<br>    std::multiset&lt;<span class="hljs-type">int</span>&gt; st;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++) &#123;<br>        <span class="hljs-keyword">if</span> (a[i] &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>        st.<span class="hljs-built_in">insert</span>(a[i]);<br>        sum += a[i];<br>        <span class="hljs-keyword">if</span> (st.<span class="hljs-built_in">size</span>() &gt; m) &#123;<br>            sum -= *st.<span class="hljs-built_in">begin</span>();<br>            st.<span class="hljs-built_in">erase</span>(st.<span class="hljs-built_in">begin</span>());<br>        &#125;<br>        ans = std::<span class="hljs-built_in">max</span>(ans, sum - <span class="hljs-number">1LL</span> * i * d);<br>    &#125;<br><br>    std::cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-type">int</span> tt = <span class="hljs-number">1</span>;<br>    std::cin &gt;&gt; tt;<br>    <span class="hljs-keyword">while</span> (tt --) <span class="hljs-built_in">solve</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></details><p><br></p><hr /><h2 id="f---magic-will-save-the-world-cf1862-f"><ahref="https://codeforces.com/contest/1862/problem/F">F - Magic Will Savethe World (CF1862 F)</a></h2><h3 id="题目大意-5">题目大意</h3><p>&lt;++&gt;</p><h3 id="解题思路-5">解题思路</h3><p>假设所有怪兽的总血量为<spanclass="math inline">\(s\)</span>，其中有<spanclass="math inline">\(x\)</span>滴血被水解决，剩下<spanclass="math inline">\(s - x\)</span>血量用火解决。则答案为<spanclass="math inline">\(max(\frac{x}{w}, \frac{s - x}{f})\)</span>。用<spanclass="math inline">\(0/1\)</span>背包预处理才出所有能取到的怪兽血量的集合，然后枚举更新答案即可。</p><details><summary>神奇的代码</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br> <br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br> <br><span class="hljs-function"><span class="hljs-type">int32_t</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> q;<br>    cin &gt;&gt; q;<br>    <span class="hljs-keyword">while</span> (q--) &#123;<br>        <span class="hljs-type">int</span> w, f, n;<br>        cin &gt;&gt; w &gt;&gt; f &gt;&gt; n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">s</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-type">int</span> sum_s = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            cin &gt;&gt; s[i];<br>            sum_s += s[i];<br>        &#125;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(sum_s + <span class="hljs-number">1</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> w = sum_s; w - s[i] &gt;= <span class="hljs-number">0</span>; --w) &#123;<br>                dp[w] = dp[w] || dp[w - s[i]];<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">2e9</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= sum_s; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (dp[i]) &#123;<br>                ans = <span class="hljs-built_in">min</span>(ans, <span class="hljs-built_in">max</span>((i + w - <span class="hljs-number">1</span>) / w, (sum_s - i + f - <span class="hljs-number">1</span>) / f));<br>            &#125;<br>        &#125;<br>        cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></details><p><br></p><hr /><h2 id="g---the-great-equalizer-cf1862-g"><ahref="https://codeforces.com/contest/1862/problem/G">G - The GreatEqualizer (CF1862 G)</a></h2><h3 id="题目大意-6">题目大意</h3><p>&lt;++&gt;</p><h3 id="解题思路-6">解题思路</h3><p>设<span class="math inline">\(d\)</span>数组为原数组数组排序后的差，猜的结论：<span class="math inline">\(ans = max(a) + max(d)\)</span></p><details><summary>神奇的代码</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> i64 = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    std::cin &gt;&gt; n;<br>    <br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        std::cin &gt;&gt; a[i];<br>    &#125;<br>    <br>    std::multiset&lt;<span class="hljs-type">int</span>&gt; s, d&#123;<span class="hljs-number">0</span>&#125;;<br>    <br>    <span class="hljs-keyword">auto</span> add = [&amp;](<span class="hljs-type">int</span> x) &#123;<br>        <span class="hljs-keyword">auto</span> it = s.<span class="hljs-built_in">insert</span>(x);<br>        <span class="hljs-keyword">auto</span> r = std::<span class="hljs-built_in">next</span>(it);<br>        <span class="hljs-keyword">if</span> (it != s.<span class="hljs-built_in">begin</span>()) &#123;<br>            d.<span class="hljs-built_in">insert</span>(x - *std::<span class="hljs-built_in">prev</span>(it));<br>        &#125;<br>        <span class="hljs-keyword">if</span> (r != s.<span class="hljs-built_in">end</span>()) &#123;<br>            d.<span class="hljs-built_in">insert</span>(*r - x);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (it != s.<span class="hljs-built_in">begin</span>() &amp;&amp; r != s.<span class="hljs-built_in">end</span>()) &#123;<br>            d.<span class="hljs-built_in">extract</span>(*r - *std::<span class="hljs-built_in">prev</span>(it));<br>        &#125;<br>    &#125;;<br>    <br>    <span class="hljs-keyword">auto</span> del = [&amp;](<span class="hljs-type">int</span> x) &#123;<br>        <span class="hljs-keyword">auto</span> it = s.<span class="hljs-built_in">find</span>(x);<br>        <span class="hljs-keyword">auto</span> r = std::<span class="hljs-built_in">next</span>(it);<br>        <span class="hljs-keyword">if</span> (it != s.<span class="hljs-built_in">begin</span>()) &#123;<br>            d.<span class="hljs-built_in">extract</span>(x - *std::<span class="hljs-built_in">prev</span>(it));<br>        &#125;<br>        <span class="hljs-keyword">if</span> (r != s.<span class="hljs-built_in">end</span>()) &#123;<br>            d.<span class="hljs-built_in">extract</span>(*r - x);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (it != s.<span class="hljs-built_in">begin</span>() &amp;&amp; r != s.<span class="hljs-built_in">end</span>()) &#123;<br>            d.<span class="hljs-built_in">insert</span>(*r - *std::<span class="hljs-built_in">prev</span>(it));<br>        &#125;<br>        s.<span class="hljs-built_in">erase</span>(it);<br>    &#125;;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">add</span>(a[i]);<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> q;<br>    std::cin &gt;&gt; q;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; q; i++) &#123;<br>        <span class="hljs-type">int</span> x, y;<br>        std::cin &gt;&gt; x &gt;&gt; y;<br>        x--;<br>        <span class="hljs-built_in">del</span>(a[x]);<br>        a[x] = y;<br>        <span class="hljs-built_in">add</span>(a[x]);<br>        <span class="hljs-type">int</span> ans = *s.<span class="hljs-built_in">rbegin</span>() + *d.<span class="hljs-built_in">rbegin</span>();<br>        std::cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[i == q - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    <br>    <span class="hljs-type">int</span> t;<br>    std::cin &gt;&gt; t;<br>    <br>    <span class="hljs-keyword">while</span> (t--) &#123;<br>        <span class="hljs-built_in">solve</span>();<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></details><p><br></p><hr />]]></content>
    
    
    <summary type="html">我好菜啊</summary>
    
    
    
    <category term="算法题解" scheme="https://acmicpc.top/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="codeforces" scheme="https://acmicpc.top/tags/codeforces/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces Round 893 (Div. 2)</title>
    <link href="https://acmicpc.top/2023/08/29/Codeforces%20Round%20893%20(Div.%202)/"/>
    <id>https://acmicpc.top/2023/08/29/Codeforces%20Round%20893%20(Div.%202)/</id>
    <published>2023-08-28T16:04:20.000Z</published>
    <updated>2023-08-30T10:07:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="a---buttons-cf1858-a"><ahref="https://codeforces.com/contest/1858/problem/A">A - Buttons (CF1858A)</a></h2><h3 id="题目大意">题目大意</h3><p>anna和katie轮流按按钮，anna只能按按钮A和C，katie只能按下按钮B和C。不能按下按钮的一方输。求最后谁赢</p><h3 id="解题思路">解题思路</h3><p>根据峡谷经济学，有中立资源时先控中立资源。</p><details><summary>神奇的代码</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> i64 = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    i64 a, b, c;<br>    std::cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br><br>    i64 tmp = (c + <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>;<br>    a += tmp; b += c - tmp;<br><br>    <span class="hljs-keyword">if</span> (a &gt; b) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;First&quot;</span> &lt;&lt; std::endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Second&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-type">int</span> tt = <span class="hljs-number">1</span>;<br>    std::cin &gt;&gt; tt;<br>    <span class="hljs-keyword">while</span> (tt --) <span class="hljs-built_in">solve</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></details><p><br></p><hr /><h2 id="b---the-walkway-cf1858-b"><ahref="https://codeforces.com/contest/1858/problem/B">B - The Walkway(CF1858 B)</a></h2><h3 id="题目大意-1">题目大意</h3><p>太长不写版</p><h3 id="解题思路-1">解题思路</h3><p>BC难度反了。注意到每次删掉椅子，贡献最多减一，枚举减掉哪个就行。提前存储下吃饼干的点可以化简复杂度。</p><details><summary>神奇的代码</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> i64 = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> PII = std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m, d;<br>    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; d;<br><br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(m + <span class="hljs-number">2</span>)</span></span>;<br>    a[<span class="hljs-number">0</span>] = -d + <span class="hljs-number">1</span>;<br>    a[m + <span class="hljs-number">1</span>] = n + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>  (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= m;i ++) &#123;<br>        std::cin &gt;&gt; a[i];<br>    &#125;<br><br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= m + <span class="hljs-number">1</span>;i ++) &#123;<br>        cnt += (a[i] - a[i - <span class="hljs-number">1</span>] - <span class="hljs-number">1</span>) / d;<br>    &#125;<br><br>    <span class="hljs-type">int</span> res = (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>), ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= m;i ++) &#123;<br>        <span class="hljs-type">int</span> tmp = cnt;<br>        tmp -= (a[i] - a[i - <span class="hljs-number">1</span>] - <span class="hljs-number">1</span>) / d;<br>        tmp -= (a[i + <span class="hljs-number">1</span>] - a[i] - <span class="hljs-number">1</span>) / d;<br>        tmp += (a[i + <span class="hljs-number">1</span>] - a[i - <span class="hljs-number">1</span>] - <span class="hljs-number">1</span>) / d;<br>        tmp += m - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (tmp &lt; res) &#123;<br>            res = tmp;<br>            ans = <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (res == tmp) &#123;<br>            ans ++;<br>        &#125;<br>    &#125;<br><br>    std::cout &lt;&lt; res &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; ans &lt;&lt; std::endl;<br>    <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-type">int</span> tt = <span class="hljs-number">1</span>;<br>    std::cin &gt;&gt; tt;<br>    <span class="hljs-keyword">while</span> (tt --) <span class="hljs-built_in">solve</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></details><p><br></p><hr /><h2 id="c---yet-another-permutation-problem-cf1858-c"><ahref="https://codeforces.com/contest/1858/problem/C">C - Yet AnotherPermutation Problem (CF1858 C)</a></h2><h3 id="题目大意-2">题目大意</h3><p>找到一个排列，使得相邻两个数的gcd的不同个数最多</p><h3 id="解题思路-2">解题思路</h3><p>按倍数构造，一眼题。</p><details><summary>神奇的代码</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> i64 = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> PII = std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    std::cin &gt;&gt; n;<br><br>    std::cout &lt;&lt; <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br><br>    std::bitset&lt;100010&gt; vis;<br>    vis[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;i &lt;= n;i ++) &#123;<br>        <span class="hljs-keyword">if</span> (vis[i]) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i;j &lt;= n;j += j) &#123;<br>            <span class="hljs-keyword">if</span> (!vis[j]) vis[j] = <span class="hljs-literal">true</span>;<br>            std::cout &lt;&lt; j &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>        &#125;<br>    &#125;<br>    <br>    std::cout &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-type">int</span> tt = <span class="hljs-number">1</span>;<br>    std::cin &gt;&gt; tt;<br>    <span class="hljs-keyword">while</span> (tt --) <span class="hljs-built_in">solve</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></details><p><br></p><hr /><h2 id="d---trees-and-segments-cf1858-d"><ahref="https://codeforces.com/contest/1858/problem/D">D - Trees andSegments (CF1858 D)</a></h2><h3 id="题目大意-3">题目大意</h3><p>&lt;++&gt;</p><h3 id="解题思路-3">解题思路</h3><p>&lt;++&gt;</p><details><summary>神奇的代码</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br></code></pre></td></tr></table></figure></details><p><br></p><hr /><h2 id="e1---rollbacks-easy-version-cf1858-e1"><ahref="https://codeforces.com/contest/1858/problem/E1">E1 - Rollbacks(Easy Version) (CF1858 E1)</a></h2><h3 id="题目大意-4">题目大意</h3><p>&lt;++&gt;</p><h3 id="解题思路-4">解题思路</h3><p>&lt;++&gt;</p><details><summary>神奇的代码</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br></code></pre></td></tr></table></figure></details><p><br></p><hr /><h2 id="e2---rollbacks-hard-version-cf1858-e2"><ahref="https://codeforces.com/contest/1858/problem/E2">E2 - Rollbacks(Hard Version) (CF1858 E2)</a></h2><h3 id="题目大意-5">题目大意</h3><p>&lt;++&gt;</p><h3 id="解题思路-5">解题思路</h3><p>&lt;++&gt;</p><details><summary>神奇的代码</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br></code></pre></td></tr></table></figure></details><p><br></p><hr />]]></content>
    
    
    <summary type="html">我好菜啊</summary>
    
    
    
    <category term="算法题解" scheme="https://acmicpc.top/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="codeforces" scheme="https://acmicpc.top/tags/codeforces/"/>
    
  </entry>
  
</feed>
